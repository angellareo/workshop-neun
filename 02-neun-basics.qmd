---
title: "Part 2: Getting Started with Neun"
subtitle: "Introduction to the Neun Library"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: show
---

## Introduction to Neun

[Neun](https://github.com/GNB-UAM/Neun/) is a high-performance C++ library for simulating dynamical systems, aimed at modeling neural networks.

The `neun_py` package provides Python bindings to use Neun, giving users access to Neun's efficient C++ implementation in Python.

### Why Neun?

- **High performance**: C++ core with optimized numerical integrators
- **Type safe**: Automatic enum generation for variables and parameters
- **Flexible**: Multiple neuron models (Hodgkin-Huxley, Hindmarsh-Rose, Izhikevich, etc.)
- **Multiple integrators**: RungeKutta4, RungeKutta6, Euler, and Stepper
- **Precision options**: Both float and double precision support
- **Header-Only C++ library**: Easy integration in C++ projects

## Installation and Setup

### Installing Neun

First, ensure you have Python 3.8+ and a C++ compiler with C++20 support (GCC 10+, Clang 10+). You'll need to install the Neun C++ library first, then build the Python bindings.

::: {.callout-tip}
## Using Virtual Environments

It's recommended to use a virtual environment for the workshop:

```bash
python -m venv neun-workshop
source neun-workshop/bin/activate  # On Windows: neun-workshop\Scripts\activate
pip install -r requirements.txt
```
:::

#### Installing the C++ Library

```bash
# Clone and build Neun
git clone https://github.com/GNB-UAM/Neun.git
cd Neun
mkdir build && cd build
cmake ..
make
sudo make install
```

#### Installing Python Bindings

```bash
# Clone and build neun_py
git clone https://github.com/GNB-UAM/neun_py.git
cd neun_py
make  # Generates code and installs in editable mode

# Or install with optional dependencies for examples
pip install neun_py[examples]  # Includes matplotlib and numpy
```
Let's check that everything (both the C++ library and the Python bindings) is installed correctly.

### Verifying Installation of the Neun C++ library

```bash
echo '#include <DifferentialNeuronWrapper.h>
#include <HodgkinHuxleyModel.h>
#include <RungeKutta4.h>
#include <SystemWrapper.h>
#include <iostream>
typedef RungeKutta4 Integrator;
typedef DifferentialNeuronWrapper<SystemWrapper<HodgkinHuxleyModel<double>>, Integrator>
    Neuron;

int main() {
    // Struct to initialize neuron model parameters
    Neuron::ConstructorArgs args;

    // Initialize a new neuron model
    Neuron n(args);

    std::cout << "Neun C++ library loaded successfully!" << std::endl;
    return 0;
}' > test_neun.cpp
g++ -std=c++20 test_neun.cpp -o test_neun -I/usr/local/Neun/0.4.0/
# clang++ -std=c++20 test_neun.cpp -o test_neun -I/usr/local/Neun/0.4.0/  # If using Clang
./test_neun
```

::: {.callout-tip}
## Use an appropriate C++ compiler
Make sure to use a C++ compiler that supports C++20 (e.g., GCC 10+, Clang 10+).

If you are using Windows, consider installing MinGW or using WSL for a Linux-like environment.

If you are using MacOS, you may need to install GCC/Clang via Homebrew: brew install gcc
:::

### Verifying Installation of the neun_py Python Bindings

Now, let's check that you can use the python bindings:

```bash
python -c 'import neun_py
import numpy as np

# Check available neuron models
neurons = neun_py.get_available_neurons()
print(f"Available neuron types: {neurons}")

# Check available synapses
synapses = neun_py.get_available_synapses()
print(f"Available synapse types: {synapses}")

print("\nNeun Python bindings loaded successfully!")'
```

::: {.callout-tip}
## Remember to use the Virtual Environment
If you set up a virtual environment, remember to activate it before running your Python scripts after this workshop:
```bash
source neun-workshop/bin/activate  # On Windows: neun-workshop\Scripts\activate
```
:::

## Neun Architecture Overview

Neun is organized around several key concepts:

### 1. Neurons

Individual computational units that integrate inputs and generate outputs. Neun provides several biophysically-based neuron models.

**Available neuron models**:

| Model | Short Name | Description |
|-------|------------|-------------|
| **Hodgkin-Huxley** | `HH` | Classic conductance-based model |
| **Hindmarsh-Rose** | `HR` | Simplified bursting model |
| **Izhikevich**     |      | Izhikevich spiking neuron model (2003) |
| **Matsuoka**       |      | Matsuoka oscillator (1985) |
| **RowatSelverston**|      | Rowat and Selverston model (1997) |
| **Rulkov**         |      | Rulkov Map model (2002) |
| **Vavoulis**       |      | Vavoulis model (2007) |

**Naming convention**: Models are named as `{Model}{Precision}{Integrator}`
- Example: `HHDoubleRK4` = Hodgkin-Huxley, Double precision, RungeKutta4

### 2. Synapses

Connections between neurons that transmit signals.

**Available synapse types**:

- **Diffusion Synapse**: Based on Destexhe et al. 1994
- **Electrical Synapse** (`ESyn`): Gap junction coupling
<!-- These are not currently available in neun_py:
- **Conductance-based Direct Synapse**: Synaptic conductance
- **Sigmoidal Direct Synapse**: Nonlinear transmission -->

**Naming convention**: `{SynapseType}{Neuron1}{Neuron2}{Precision}{Integrator}`
- Example: `ESynHHHHDoubleRK4` = Electrical synapse between two HH neurons

### 3. Integrators

Numerical methods for solving differential equations.

**Available integrators**:

- **RK4**: 4th-order Runge-Kutta (most common)
- **RK6**: 6th-order Runge-Kutta (higher accuracy)
- **Euler**: Simple Euler method
- **Stepper**: Basic stepping

### 4. Parameters and Variables

Neun uses type-safe enums for accessing neuron properties:

- **Parameters**: Model constants (e.g., conductances, capacitances)
  - Set value using `neuron.set_param(enum, value)`
- **Variables**: Dynamic state (e.g., membrane potential, gating variables)
  - Set value using `neuron.set_var(enum, value)` or `neuron.set(enum, value)`
  - Get using `neuron.get(enum)`

Example enums: `HHDoubleParameter.cm`, `HHDoubleVariable.v`

## Your First Neun Program

Let's create a simple Hodgkin-Huxley neuron simulation to understand the basic workflow:

```{.python filename="src/first-program.py"}
{{< include src/first-program.py >}}
```

::: {.callout-note}
## Understanding the Workflow

The basic Neun workflow consists of:

1. **Instantiate neuron** with model type, precision, and integrator
2. **Create constructor args** for the neuron model and **set parameters** using enums (e.g., `HHDoubleParameter.cm`)
4. \[Optional] **Set initial conditions** for variables
5. **Simulate** by stepping through time with `neuron.step(dt)`
6. **Add inputs** with `neuron.add_synaptic_input(current)`
7. **Read state** using `neuron.get(variable_enum)`
:::

## Exploring Neuron Models

### Hodgkin-Huxley (HH)

The classic biophysical neuron model with sodium and potassium conductances:

```{.python filename="src/hh.py"}
{{< include src/hh.py >}}
```

**Observation**: Higher external current leads to:
- More frequent action potentials
- Higher firing rate
- Different spiking patterns

### Hindmarsh-Rose (HR)

A reduced model that can produce bursting and chaotic behavior:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Different parameter sets for HR neuron
parameter_sets = [
    {'name': 'Regular Spiking', 'I': 3.0},
    {'name': 'Bursting', 'I': 3.5},
    {'name': 'Chaotic', 'I': 3.8},
]

fig, axes = plt.subplots(len(parameter_sets), 1, figsize=(12, 8))

dt = 0.01
T = 500
time = np.arange(0, T, dt)

for idx, params in enumerate(parameter_sets):
    # Create Hindmarsh-Rose neuron
    args = neun_py.HRDoubleConstructorArgs()
    neuron = neun_py.HRDoubleRK4(args)
    
    # HR model uses default parameters, but we can modify them if needed
    # Set initial conditions
    neuron.set_var(neun_py.HRDoubleVariable.x, -1.0)
    neuron.set_var(neun_py.HRDoubleVariable.y, -5.0)
    neuron.set_var(neun_py.HRDoubleVariable.z, 0.0)
    
    # Simulate with different input currents
    V = []
    for t in time:
        neuron.add_synaptic_input(params['I'])
        neuron.step(dt)
        V.append(neuron.get(neun_py.HRDoubleVariable.x))  # x is membrane potential
    
    # Plot
    axes[idx].plot(time, V, 'b-', linewidth=1)
    axes[idx].set_title(f"{params['name']} (I = {params['I']})")
    axes[idx].set_ylabel('Membrane Potential')
    axes[idx].grid(True, alpha=0.3)
    if idx == len(parameter_sets) - 1:
        axes[idx].set_xlabel('Time (ms)')

plt.suptitle('Hindmarsh-Rose Neuron: Different Firing Patterns', fontsize=14)
plt.tight_layout()
plt.show()
```

::: {.callout-important}
## Choosing a Neuron Model

- **HH (Hodgkin-Huxley)**: Biophysically detailed, captures ion channel dynamics
- **HR (Hindmarsh-Rose)**: Bursting and chaotic behavior, moderate complexity
- **Izhikevich**: Various firing patterns with simple equations

**Integrator Selection**:

- **RK4**: Best balance of accuracy and speed (recommended)
- **RK6**: Higher accuracy for sensitive systems
- **Euler**: Fast but less accurate

**Precision**: Use `Double` for most cases, `Float` for large-scale simulations
:::

## Input Patterns

Neun supports [various input patterns](input-patterns.qmd) through `add_synaptic_input()`.

## Recording and Analysis

Since neun_py doesn't have a built-in recorder, we manually store the data we need:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Create neuron
args = neun_py.HHDoubleConstructorArgs()
neuron = neun_py.HHDoubleRK4(args)

# Set parameters
neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)
neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)
neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)
neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)
neuron.set_param(neun_py.HHDoubleParameter.gna, 120 * 7.854e-3)
neuron.set_param(neun_py.HHDoubleParameter.gk, 36 * 7.854e-3)
neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)

# Set initial conditions
neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)

# Simulate and record multiple variables
dt = 0.001
T = 100
time = np.arange(0, T, dt)

# Storage arrays
V = []      # Membrane potential
m_vals = [] # Na activation
h_vals = [] # Na inactivation  
n_vals = [] # K activation

for t in time:
    neuron.add_synaptic_input(0.1)
    neuron.step(dt)
    
    # Record all variables of interest
    V.append(neuron.get(neun_py.HHDoubleVariable.v))
    m_vals.append(neuron.get(neun_py.HHDoubleVariable.m))
    h_vals.append(neuron.get(neun_py.HHDoubleVariable.h))
    n_vals.append(neuron.get(neun_py.HHDoubleVariable.n))

# Plot multiple variables
fig, axes = plt.subplots(4, 1, figsize=(10, 10), sharex=True)

axes[0].plot(time, V, 'b-', linewidth=1.5)
axes[0].set_ylabel('V (mV)')
axes[0].set_title('Membrane Potential')
axes[0].grid(True, alpha=0.3)

axes[1].plot(time, m_vals, 'r-', linewidth=1.5)
axes[1].set_ylabel('m')
axes[1].set_title('Na Activation')
axes[1].grid(True, alpha=0.3)

axes[2].plot(time, h_vals, 'g-', linewidth=1.5)
axes[2].set_ylabel('h')
axes[2].set_title('Na Inactivation')
axes[2].grid(True, alpha=0.3)

axes[3].plot(time, n_vals, 'orange', linewidth=1.5)
axes[3].set_ylabel('n')
axes[3].set_title('K Activation')
axes[3].set_xlabel('Time (ms)')
axes[3].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Parameter Exploration

A key use of simulations is exploring parameter space:


```{.python filename="src/parameter-exploration.py"}
{{< include src/parameter-exploration.py >}}
```

::: {.callout-tip}
## Parameter Exploration Tips

1. **Start with wide ranges** to understand overall behavior
2. **Refine** around interesting regions
3. **Vary one parameter at a time** initially
4. **Use multiple metrics** (firing rate, CV of ISI, etc.)
5. **Compare with experimental data** when available
:::

## Running Multiple Trials

```python
import neun_py
import numpy as np

n_trials = 10
all_voltages = []

dt = 0.001
T = 100
time = np.arange(0, T, dt)

for trial in range(n_trials):
    # Create fresh neuron for each trial
    args = neun_py.HHDoubleConstructorArgs()
    neuron = neun_py.HHDoubleRK4(args)
    
    # Set parameters (use helper function from earlier)
    set_hh_params(neuron, HH_PARAMS)
    
    # Set initial conditions
    neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
    neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
    neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
    neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)
    
    V = []
    for t in time:
        # Add noisy input
        I_noisy = 0.1 + 0.05 * np.random.randn()
        neuron.add_synaptic_input(I_noisy)
        neuron.step(dt)
        V.append(neuron.get(neun_py.HHDoubleVariable.v))
    
    all_voltages.append(V)

# Analyze trial-to-trial variability
all_voltages = np.array(all_voltages)
mean_voltage = np.mean(all_voltages, axis=0)
std_voltage = np.std(all_voltages, axis=0)

print(f"Mean voltage at t=50ms: {mean_voltage[int(50/dt)]:.2f} ± {std_voltage[int(50/dt)]:.2f} mV")
```

### Batch Processing

```python
import neun_py
import numpy as np

# Test multiple parameter combinations
param_grid = {
    'gna': [100, 120, 140],  # mS/cm² (before scaling)
    'gk': [30, 36, 42]       # mS/cm² (before scaling)
}

results = []

dt = 0.001
T = 100
time = np.arange(0, T, dt)

for gna in param_grid['gna']:
    for gk in param_grid['gk']:
        # Create neuron
        args = neun_py.HHDoubleConstructorArgs()
        neuron = neun_py.HHDoubleRK4(args)
        
        # Set parameters with varied conductances
        neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)
        neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)
        neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)
        neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)
        neuron.set_param(neun_py.HHDoubleParameter.gna, gna * 7.854e-3)
        neuron.set_param(neun_py.HHDoubleParameter.gk, gk * 7.854e-3)
        neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)
        
        # Set initial conditions
        neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
        neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
        neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
        neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)
        
        # Simulate
        V = []
        for t in time:
            neuron.add_synaptic_input(0.1)
            neuron.step(dt)
            V.append(neuron.get(neun_py.HHDoubleVariable.v))
        
        # Detect spikes
        V_array = np.array(V)
        n_spikes = np.sum((V_array[:-1] < 0) & (V_array[1:] >= 0))
        
        results.append({
            'gna': gna,
            'gk': gk,
            'n_spikes': n_spikes,
            'mean_voltage': np.mean(V)
        })

# Analyze results
import pandas as pd
df = pd.DataFrame(results)
print(df)
```

## Summary

In this section, we've learned:

- ✅ How to install Neun C++ library and neun_py Python bindings
- ✅ Basic architecture: neurons, synapses, integrators, parameters/variables
- ✅ Creating and simulating Hodgkin-Huxley neurons with neun_py
- ✅ Manual recording and analyzing results
- ✅ Parameter exploration and sweeps
- ✅ Best practices for simulation code

::: {.callout-note}
## Key Takeaways

1. **Neun workflow**: Create args → Instantiate model → Set params → Set vars → Simulate → Record
2. **Type safety**: Use enums for parameters and variables (e.g., `HHDoubleParameter.cm`)
3. **Model naming**: `{Model}{Precision}{Integrator}` (e.g., `HHDoubleRK4`)
4. **Synapses**: Named as `{Type}{Neuron1}{Neuron2}{Precision}{Integrator}`
5. **Organization**: Write helper functions for creating and configuring neurons
:::

## Exercises

Try these exercises to solidify your understanding:

1. **Parameter Sweep**: Create a 2D parameter sweep varying both `gna` and `gk` in the HH model
2. **Integrator Comparison**: Compare RK4 vs RK6 integrators for the same HH neuron
3. **Phase Plane**: Plot the (V, n) phase plane for the HH model
4. **Coupling Strength**: Explore how synapse conductance affects synchronization between two HR neurons
5. **Noise Effects**: Compare firing patterns with different noise levels in the input current

## Next Steps

Now that you're familiar with Neun basics, we'll move on to:

- Simulating synaptic dynamics
- Creating connected networks
- Analyzing network behavior

---

**Continue to [Part 3: Single Neuron Modeling](03-single-neurons.qmd)**
