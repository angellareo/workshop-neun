---
title: "2.1 Getting Started with Neun"
subtitle: "Introduction to the Neun Library"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: show
---

## Introduction to Neun

[Neun](https://github.com/GNB-UAM/Neun/) is a high-performance C++ library for simulating dynamical systems, aimed at modeling neural networks.

The `neun_py` package provides Python bindings to use Neun, giving users access to Neun's efficient C++ implementation in Python.

### Why Neun?

- **High performance**: C++ core with optimized numerical integrators
- **Type safe**: Automatic enum generation for variables and parameters
- **Flexible**: Multiple neuron models (Hodgkin-Huxley, Hindmarsh-Rose, Izhikevich, etc.)
- **Multiple integrators**: RungeKutta4, RungeKutta6, Euler, and Stepper
- **Precision options**: Both float and double precision support
- **Header-Only C++ library**: Easy integration in C++ projects

## Installation and Setup

### Installing Neun

First, ensure you have Python 3.8+ and a C++ compiler with C++20 support (GCC 10+, Clang 10+). You'll need to install the Neun C++ library first, then build the Python bindings.

::: {.callout-tip}
## Using Virtual Environments

It's recommended to use a virtual environment for the workshop:

```bash
python -m venv neun-workshop
source neun-workshop/bin/activate  # On Windows: neun-workshop\Scripts\activate
pip install -r requirements.txt
```
:::

#### Installing the C++ Library

```bash
# Clone and build Neun
git clone https://github.com/GNB-UAM/Neun.git
cd Neun
mkdir build && cd build
cmake ..
make
sudo make install
```

#### Installing Python Bindings

```bash
# Clone and build neun_py
git clone https://github.com/GNB-UAM/neun_py.git
cd neun_py
make  # Generates code and installs in editable mode

# Or install with optional dependencies for examples
pip install neun_py[examples]  # Includes matplotlib and numpy
```
Let's check that everything (both the C++ library and the Python bindings) is installed correctly.

### Verifying Installation of the Neun C++ library

```bash
echo '#include <DifferentialNeuronWrapper.h>
#include <HodgkinHuxleyModel.h>
#include <RungeKutta4.h>
#include <SystemWrapper.h>
#include <iostream>
typedef RungeKutta4 Integrator;
typedef DifferentialNeuronWrapper<SystemWrapper<HodgkinHuxleyModel<double>>, Integrator>
    Neuron;

int main() {
    // Struct to initialize neuron model parameters
    Neuron::ConstructorArgs args;

    // Initialize a new neuron model
    Neuron n(args);

    std::cout << "Neun C++ library loaded successfully!" << std::endl;
    return 0;
}' > test_neun.cpp
g++ -std=c++20 test_neun.cpp -o test_neun -I/usr/local/Neun/0.4.0/
# clang++ -std=c++20 test_neun.cpp -o test_neun -I/usr/local/Neun/0.4.0/  # If using Clang
./test_neun
```

::: {.callout-tip}
## Use an appropriate C++ compiler
Make sure to use a C++ compiler that supports C++20 (e.g., GCC 10+, Clang 10+).

If you are using Windows, consider installing MinGW or using WSL for a Linux-like environment.

If you are using MacOS, you may need to install GCC/Clang via Homebrew: brew install gcc
:::

### Verifying Installation of the neun_py Python Bindings

Now, let's check that you can use the python bindings:

```bash
python -c 'import neun_py
import numpy as np

# Check available neuron models
neurons = neun_py.get_available_neurons()
print(f"Available neuron types: {neurons}")

# Check available synapses
synapses = neun_py.get_available_synapses()
print(f"Available synapse types: {synapses}")

print("\nNeun Python bindings loaded successfully!")'
```

::: {.callout-tip}
## Remember to use the Virtual Environment
If you set up a virtual environment, remember to activate it before running your Python scripts after this workshop:
```bash
source neun-workshop/bin/activate  # On Windows: neun-workshop\Scripts\activate
```
:::

## Neun Architecture Overview

Neun is organized around several key concepts:

### 1. Neurons

Individual computational units that integrate inputs and generate outputs. Neun provides several biophysically-based neuron models.

**Available neuron models**:

| Model | Short Name | Description |
|-------|------------|-------------|
| **Hodgkin-Huxley** | `HH` | Classic conductance-based model |
| **Hindmarsh-Rose** | `HR` | Simplified bursting model |
| **Izhikevich**     |      | Izhikevich spiking neuron model (2003) |
| **Matsuoka**       |      | Matsuoka oscillator (1985) |
| **RowatSelverston**|      | Rowat and Selverston model (1997) |
| **Rulkov**         |      | Rulkov Map model (2002) |
| **Vavoulis**       |      | Vavoulis model (2007) |

**Naming convention**: Models are named as `{Model}{Precision}{Integrator}`
- Example: `HHDoubleRK4` = Hodgkin-Huxley, Double precision, RungeKutta4

### 2. Synapses

Connections between neurons that transmit signals.

**Available synapse types**:

- **Diffusion Synapse**: Based on Destexhe et al. 1994
- **Electrical Synapse** (`ESyn`): Gap junction coupling
<!-- These are not currently available in neun_py:
- **Conductance-based Direct Synapse**: Synaptic conductance
- **Sigmoidal Direct Synapse**: Nonlinear transmission -->

**Naming convention**: `{SynapseType}{Neuron1}{Neuron2}{Precision}{Integrator}`
- Example: `ESynHHHHDoubleRK4` = Electrical synapse between two HH neurons

### 3. Integrators

Numerical methods for solving differential equations.

**Available integrators**:

- **RK4**: 4th-order Runge-Kutta (most common)
- **RK6**: 6th-order Runge-Kutta (higher accuracy)
- **Euler**: Simple Euler method
- **Stepper**: Basic stepping

### 4. Parameters and Variables

Neun uses type-safe enums for accessing neuron properties:

- **Parameters**: Model constants (e.g., conductances, capacitances)
  - Set value using `neuron.set_param(enum, value)`
- **Variables**: Dynamic state (e.g., membrane potential, gating variables)
  - Set value using `neuron.set(enum, value)` or `neuron.set(enum, value)`
  - Get using `neuron.get(enum)`

Example enums: `HHDoubleParameter.cm`, `HHDoubleVariable.v`

## Your First Neun Program

Let's create a simple Hodgkin-Huxley neuron simulation to understand the basic workflow:

```{.python filename="src/first-program.py"}
{{< include src/first-program.py >}}
```

::: {.callout-note}
## Understanding the Workflow

The basic Neun workflow consists of:

1. **Instantiate neuron** with model type, precision, and integrator
2. **Create constructor args** for the neuron model and **set parameters** using enums (e.g., `HHDoubleParameter.cm`)
4. \[Optional] **Set initial conditions** for variables
5. **Simulate** by stepping through time with `neuron.step(dt)`
6. **Add inputs** with `neuron.add_synaptic_input(current)`
7. **Read state** using `neuron.get(variable_enum)`
:::

## Summary

In this section, we've learned:
<!-- @TODO revisar estos puntos -->

- ✅ How to install Neun C++ library and neun_py Python bindings
- ✅ Basic architecture: neurons, synapses, integrators, parameters/variables
- ✅ Creating and simulating Hodgkin-Huxley neurons with neun_py
- ✅ Manual recording and analyzing results
- ✅ Parameter exploration and sweeps
- ✅ Best practices for simulation code

::: {.callout-note}
## Key Takeaways

1. **Neun workflow**: Create args → Instantiate model → Set params → Set vars → Simulate → Record
2. **Type safety**: Use enums for parameters and variables (e.g., `HHDoubleParameter.cm`)
3. **Model naming**: `{Model}{Precision}{Integrator}` (e.g., `HHDoubleRK4`)
4. **Synapses**: Named as `{Type}{Neuron1}{Neuron2}{Precision}{Integrator}`
5. **Organization**: Write helper functions for creating and configuring neurons
:::

## Next Steps

Now that you're familiar with Neun basics, we'll move on to:

- Simulating synaptic dynamics
- Creating connected networks
- Analyzing network behavior

---

**Continue to [2.2: Modeling Neurons](03-single-neurons.qmd)**
