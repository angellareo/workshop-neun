---
title: "2.3: Synapses and Neural Networks"
subtitle: "From Single Neurons to Connected Populations"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: show
---

## Introduction

Individual neurons are the building blocks, but the real computational power of the nervous system emerges from networks. In this section, we'll explore how to connect neurons through synapses and simulate network dynamics using Neun.

Understanding networks requires grasping three key concepts:

1. **Synapses**: The connections between neurons that enable communication
2. **Connectivity**: The pattern of which neurons connect to which (the connectome)
3. **Network dynamics**: The collective behavior that emerges from neuronal interactions

## Types of Synapses

Neun provides two main types of synaptic connections, each with distinct properties and biological relevance:

::: {.panel-tabset}

### Electrical Synapses

Electrical synapses (gap junctions) provide **direct electrical coupling** between neurons through protein channels that connect their cytoplasm. This creates:

- **Instantaneous transmission**: No synaptic delay
- **Bidirectional communication**: Current flows both ways
- **Synchronization**: Tendency to align neuron activity

**Structure**: `ESynN1N2PrecisionIntegrator`

```{.python filename="src/electrical-synapse.py"}
{{< include src/electrical-synapse.py >}}
```

::: {.callout-note}
## Gap Junction Physics

The current through a gap junction is proportional to the voltage difference:
$$I_{syn} = g_{gap} \cdot (V_1 - V_2)$$

where $g_{gap}$ is the gap junction conductance (typically 0.001-0.01).
:::

:::{.callout-tip}
#### Hands-on

Try modifying the coupling conductance... ðŸ’»

- Change `-0.002` to `-0.001` (weaker coupling)
- Change to `-0.005` (stronger coupling)

What happens to the synchronization between neurons?
:::


### Diffusion Synapses

Diffusion synapses model **chemical-like coupling** with time-dependent dynamics that approximate neurotransmitter diffusion across the synaptic cleft:

- **Slower transmission**: Time-dependent dynamics
- **Filtering effects**: Can smooth rapid fluctuations  
- **Biological realism**: Better models chemical synapses

**Structure**: `DSynN1N2PrecisionIntegrator`

```{.python filename="src/diffusion-synapse.py"}
{{< include src/diffusion-synapse.py >}}
```

::: {.callout-note}
## Diffusion vs Electrical

While diffusion synapses include dynamics, they're still simplified compared to full chemical synapses. For more realistic chemical transmission (with neurotransmitter release, receptors, etc.), you'd need additional mechanisms.
:::

:::{.callout-tip}
#### Hands-on

Compare the two synapse types... ðŸ’»

Run both examples and observe:
- Which shows faster coupling?
- Which produces tighter synchronization?
- How do the voltage traces differ?
:::

:::


::: {.callout-important}
## Synapse Naming Convention

Neun follows a systematic naming pattern for synapses:

```
{SynapseType}{Neuron1Type}{Neuron2Type}{Precision}{Integrator}
```

**Examples**:
- `ESynHHHHDoubleRK4` - Electrical synapse between two HH neurons
- `DSynHRHRDoubleRK6` - Diffusion synapse between two HR neurons  
- `ESynHHHRFloatRK4` - Electrical synapse from HH to HR neuron

**Important**: [Always step synapses **before** stepping neurons](step-order.qmd) in your simulation loop!
:::

## Building Neural Networks

### Chain Network

Let's build a simple feedforward chain where activity propagates from one neuron to the next:

```{.python filename="src/neuron-chain.py"}
{{< include src/neuron-chain.py >}}
```

**Observation**: Notice how the spike travels through the chain with some delay. The coupling strength determines how effectively the signal propagates.

:::{.callout-tip}
#### Hands-on

Experiment with the chain... ðŸ’»

1. Change the coupling strength (currently `-0.002`)
2. Add input to the last neuron instead of the first
3. Add more neurons to the chain (change `4` to `6` or `8`)

What's the maximum chain length before signal dies out?
:::

### All-to-All Network

In many brain regions, neurons are densely interconnected. Let's simulate this:

```{.python filename="src/population-rate.py"}
{{< include src/population-rate.py >}}
```

::: {.callout-note}
## All-to-All Connectivity

With $N$ neurons, an all-to-all network has:
$$\text{Number of synapses} = \frac{N(N-1)}{2}$$

This scales as $O(N^2)$, so computation grows quickly with network size!
:::

## Visualizing Network Activity

Understanding network behavior requires appropriate visualization tools:

### Raster Plots

Raster plots show **spike times** for all neurons, revealing temporal patterns:

```{.python filename="src/raster-plot.py"}
{{< include src/raster-plot.py >}}
```

**What to look for**:
- **Synchrony**: Vertical alignment of spikes
- **Propagation**: Diagonal patterns
- **Rhythms**: Regular spacing

:::{.callout-tip}
#### Hands-on

Analyze the raster plot... ðŸ’»

- Can you identify synchronized events?
- Do you see traveling waves?
- Try increasing the coupling strength - what changes?
:::

### Population Firing Rate

The population firing rate captures **collective activity**:

Already shown in the all-to-all network example above! The population firing rate is computed using a sliding window to count spikes across the network.

::: {.callout-note}
## Computing Firing Rates

Common approaches:
1. **Spike counting**: Count spikes in time window, divide by window size
2. **Instantaneous rate**: Inverse of inter-spike interval
3. **Kernel smoothing**: Convolve spike train with Gaussian

Each has trade-offs between temporal resolution and noise!
:::

## Network Synchronization

How coupled neurons synchronize depends on the **coupling strength**:

```{.python filename="src/coupling-strength.py"}
{{< include src/coupling-strength.py >}}
```

::: {.callout-important}
## Synchronization Mechanisms

Electrical synapses promote synchronization through:

1. **Direct coupling**: Voltage differences drive equalizing currents
2. **Phase locking**: Neurons adjust their firing times to match
3. **Resonance**: Coupling most effective near natural frequencies

But too much synchronization can be pathological (e.g., epilepsy)!
:::

:::{.callout-tip}
#### Hands-on

Explore synchronization... ðŸ’»

1. What coupling strength gives 50% synchronization?
2. Is there a threshold effect?
3. Try different initial voltage differences - does it matter?
:::

## Central Pattern Generators (CPGs)

CPGs are neural circuits that produce **rhythmic patterns** without rhythmic input. They're essential for locomotion, breathing, and other rhythmic behaviors.

Key features of CPGs:
- **Intrinsic rhythmicity**: Generated by network dynamics, not input
- **Phase relationships**: Neurons fire in specific temporal order
- **Robustness**: Maintain rhythm despite perturbations

### Reciprocal Inhibition Model

A classic CPG uses two neurons with mutual inhibition creating alternating bursts:

```{.python filename="src/cpg-analysis.py"}
{{< include src/cpg-analysis.py >}}
```

::: {.callout-note}
## CPG Analysis Metrics

**Inter-Burst Interval (IBI)**: Time between successive bursts in one neuron
- Measures rhythm regularity
- CV of IBI < 0.1 indicates regular rhythm

**Phase Lag**: Time difference between corresponding events in two neurons
- Characterizes coordination
- For anti-phase: lag â‰ˆ half the cycle period

**Duty Cycle**: Fraction of time neuron is active
- Active time / cycle period
- Typical values: 0.3-0.5 for alternating rhythms
:::

:::{.callout-tip}
#### Hands-on

Modify the CPG... ðŸ’»

1. Change coupling strength (`-0.05` â†’ `-0.03` or `-0.08`)
2. Try asymmetric coupling (different values for each direction)
3. Adjust external drive `I` parameter

Can you create a different phase relationship?

<details>
<summary>Hint</summary>
Stronger coupling â†’ faster synchronization  
Asymmetric coupling â†’ asymmetric phase relationship  
Higher drive â†’ faster rhythm
</details>
:::

## Excitation-Inhibition Balance

Real neural networks contain both excitatory and inhibitory neurons. The balance between them is critical for stable dynamics.

::: {.callout-note}
## E-I Balance Principles

- **Too much excitation**: Runaway activity, seizures
- **Too much inhibition**: Network shuts down, no response  
- **Balanced**: Stable, responsive, rich dynamics

Typical cortical networks: ~80% excitatory, ~20% inhibitory neurons

Current Neun implementation focuses on electrical and diffusion coupling. For explicit excitatory/inhibitory synapses, you can:
1. Use coupling conductance sign and magnitude
2. Implement through the external input mechanism
3. Wait for future Neun updates with chemical synapse models!
:::

## Best Practices for Network Simulations

::: {.callout-important}
## Simulation Tips

**1. Update Order Matters**
```python
# Correct order:
for synapse in synapses:
    synapse.step(step)
    
for neuron in neurons:
    neuron.step(step)
```

**2. Pre-allocate Storage**
```python
# Efficient for large networks
n_steps = int(duration / step)
voltages = np.zeros((n_neurons, n_steps))
```

**3. Choose Appropriate Time Steps**
- Too large: Numerical instability
- Too small: Slow simulation
- Typical: 0.001-0.01 ms for HH neurons

**4. Monitor for Pathological States**
- Check for NaN or infinite values
- Watch for runaway excitation
- Validate with known behaviors
:::

## Advanced Topics

<details>
<summary>Scaling to Larger Networks</summary>

For networks with hundreds or thousands of neurons:

1. **Sparse connectivity**: Not all-to-all, but random with probability $p$
2. **Vectorization**: Use NumPy arrays for batch operations
3. **Precision trade-offs**: Consider `Float` vs `Double`
4. **Parallel simulation**: Multiple independent networks

Example sparse connection:
```python
connection_prob = 0.1  # 10% connectivity
for i in range(n_neurons):
    for j in range(i+1, n_neurons):
        if np.random.random() < connection_prob:
            # Create synapse between i and j
            pass
```
</details>

<details>
<summary>Network Topology Matters</summary>

Different connectivity patterns produce different dynamics:

- **All-to-all**: Strong synchronization
- **Chain**: Wave propagation
- **Ring**: Persistent traveling waves
- **Random**: Complex, irregular dynamics
- **Small-world**: Balance of local and global connectivity

Try implementing different topologies and observe the emergent dynamics!
</details>

<details>
<summary>Analyzing Network Oscillations</summary>

Networks can generate rhythms at different frequencies:

- **Gamma (30-80 Hz)**: Fast inhibitory feedback
- **Beta (13-30 Hz)**: Motor planning and attention
- **Alpha (8-13 Hz)**: Relaxed wakefulness  
- **Theta (4-8 Hz)**: Memory and navigation

Use Fourier analysis to identify oscillation frequencies:
```python
from scipy import signal

# Compute power spectrum
freqs, psd = signal.welch(population_rate, fs=1/(step/1000))

# Find peak frequency
peak_freq = freqs[np.argmax(psd)]
print(f"Peak oscillation: {peak_freq:.1f} Hz")
```
</details>

## Summary

In this section, we covered:

- âœ… **Synapse types**: Electrical (gap junctions) vs diffusion (chemical-like)
- âœ… **Building networks**: From simple chains to all-to-all connectivity
- âœ… **Visualization**: Raster plots and population firing rates
- âœ… **Synchronization**: How coupling strength affects coordination
- âœ… **Central Pattern Generators**: Intrinsic rhythms from reciprocal coupling
- âœ… **Network analysis**: IBIs, phase relationships, and temporal patterns

**Key takeaways**:
- Synapses create the connectivity that enables network computation
- Small changes in coupling can dramatically alter network behavior
- Appropriate visualization reveals patterns invisible in raw data
- CPGs demonstrate how networks generate complex behaviors autonomously

## Exercises

Test your understanding with these challenges:

1. **Bidirectional vs Unidirectional**: Create a synapse with asymmetric coupling (different conductances in each direction). How does this affect synchronization?

2. **Network motifs**: Build a 3-neuron network with a "feedback loop" (1â†’2â†’3â†’1). Compare its dynamics to a simple chain.

3. **Heterogeneous network**: Create a network mixing HH and HR neurons. Use `ESynHHHRDoubleRK4` for cross-type connections.

4. **Phase analysis**: For the CPG, compute the phase difference as a percentage of the cycle period. Is it stable at 50%?

5. **Critical coupling**: Find the minimum coupling strength needed for a chain of 5 neurons to propagate a signal from first to last.

6. **Oscillation frequency**: Modify CPG parameters to generate faster rhythms. Can you reach 10 Hz? 50 Hz?

<details>
<summary>Solution Hints</summary>

**Ex 1**: Use different values for the two conductance parameters:
```python
synapse = neun_py.ESynHHHHDoubleRK4(h1, v, h2, v, -0.003, -0.001)
```

**Ex 3**: Mix neuron types by creating different neurons and using cross-type synapse classes:
```python
hh_neuron = neun_py.HHDoubleRK4(hh_args)
hr_neuron = neun_py.HRDoubleRK4(hr_args)
synapse = neun_py.ESynHHHRDoubleRK4(hh_neuron, hh_v, hr_neuron, hr_v, -g, -g)
```

**Ex 6**: Increase external drive `I` parameter in HR neurons for faster bursting.
</details>

---

ðŸ‘‰ **Continue to [Part 5: Conclusions](05-conclusions.qmd)**
