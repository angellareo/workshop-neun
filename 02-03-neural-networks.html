<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2.3: Synapses and Neural Networks â€“ Introduction to Computational Neuroscience with Neun</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-988940bef898c2163ed952045d0d4fc9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./02-01-neun-basics.html">Part 2: Simulations with Neun</a></li><li class="breadcrumb-item"><a href="./02-03-neural-networks.html">Synapses &amp; Networks</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Introduction to Computational Neuroscience with Neun</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-intro-compneuro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 1: Computational Neuroscience</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Part 2: Simulations with Neun</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-01-neun-basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Intro to Neun</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-02-single-neurons.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Neurons</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-03-neural-networks.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Synapses &amp; Networks</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-conclusions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part 3: Conclusions</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="https://github.com/GNB-UAM/Neun/" class="sidebar-item-text sidebar-link"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text">Neun GitHub</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#types-of-synapses" id="toc-types-of-synapses" class="nav-link" data-scroll-target="#types-of-synapses">Types of Synapses</a></li>
  <li><a href="#building-neural-networks" id="toc-building-neural-networks" class="nav-link" data-scroll-target="#building-neural-networks">Building Neural Networks</a>
  <ul class="collapse">
  <li><a href="#chain-network" id="toc-chain-network" class="nav-link" data-scroll-target="#chain-network">Chain Network</a></li>
  <li><a href="#all-to-all-network" id="toc-all-to-all-network" class="nav-link" data-scroll-target="#all-to-all-network">All-to-All Network</a></li>
  </ul></li>
  <li><a href="#visualizing-network-activity" id="toc-visualizing-network-activity" class="nav-link" data-scroll-target="#visualizing-network-activity">Visualizing Network Activity</a>
  <ul class="collapse">
  <li><a href="#raster-plots" id="toc-raster-plots" class="nav-link" data-scroll-target="#raster-plots">Raster Plots</a></li>
  <li><a href="#population-firing-rate" id="toc-population-firing-rate" class="nav-link" data-scroll-target="#population-firing-rate">Population Firing Rate</a></li>
  </ul></li>
  <li><a href="#network-synchronization" id="toc-network-synchronization" class="nav-link" data-scroll-target="#network-synchronization">Network Synchronization</a></li>
  <li><a href="#central-pattern-generators-cpgs" id="toc-central-pattern-generators-cpgs" class="nav-link" data-scroll-target="#central-pattern-generators-cpgs">Central Pattern Generators (CPGs)</a>
  <ul class="collapse">
  <li><a href="#reciprocal-inhibition-model" id="toc-reciprocal-inhibition-model" class="nav-link" data-scroll-target="#reciprocal-inhibition-model">Reciprocal Inhibition Model</a></li>
  </ul></li>
  <li><a href="#excitation-inhibition-balance" id="toc-excitation-inhibition-balance" class="nav-link" data-scroll-target="#excitation-inhibition-balance">Excitation-Inhibition Balance</a></li>
  <li><a href="#best-practices-for-network-simulations" id="toc-best-practices-for-network-simulations" class="nav-link" data-scroll-target="#best-practices-for-network-simulations">Best Practices for Network Simulations</a></li>
  <li><a href="#advanced-topics" id="toc-advanced-topics" class="nav-link" data-scroll-target="#advanced-topics">Advanced Topics</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises">Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./02-01-neun-basics.html">Part 2: Simulations with Neun</a></li><li class="breadcrumb-item"><a href="./02-03-neural-networks.html">Synapses &amp; Networks</a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">2.3: Synapses and Neural Networks</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
<p class="subtitle lead">From Single Neurons to Connected Populations</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Individual neurons are the building blocks, but the real computational power of the nervous system emerges from networks. In this section, weâ€™ll explore how to connect neurons through synapses and simulate network dynamics using Neun.</p>
<p>Understanding networks requires grasping three key concepts:</p>
<ol type="1">
<li><strong>Synapses</strong>: The connections between neurons that enable communication</li>
<li><strong>Connectivity</strong>: The pattern of which neurons connect to which (the connectome)</li>
<li><strong>Network dynamics</strong>: The collective behavior that emerges from neuronal interactions</li>
</ol>
</section>
<section id="types-of-synapses" class="level2">
<h2 class="anchored" data-anchor-id="types-of-synapses">Types of Synapses</h2>
<p>Neun provides two main types of synaptic connections, each with distinct properties and biological relevance:</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">Electrical Synapses</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">Diffusion Synapses</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p>Electrical synapses (gap junctions) provide <strong>direct electrical coupling</strong> between neurons through protein channels that connect their cytoplasm.</p>
<p>The current through a gap junction is proportional to the voltage difference: <span class="math display">\[I_{syn} = g_{gap} \cdot (V_1 - V_2)\]</span></p>
<p>where <span class="math inline">\(g_{gap}\)</span> is the gap junction conductance (typically 0.001-0.01).</p>
<p>This creates:</p>
<ul>
<li><strong>Instantaneous transmission</strong>: No synaptic delay</li>
<li><strong>Bidirectional communication</strong>: Current flows both ways</li>
<li><strong>Synchronization</strong>: Tendency to align neuron activity</li>
</ul>
<p><strong>Structure</strong>: <code>ESynN1N2PrecisionIntegrator</code></p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>src/electrical-synapse.py</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" data-filename="src/electrical-synapse.py"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">Two neurons coupled via electrical synapse (gap junction)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">Demonstrates instantaneous bidirectional coupling</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> neun_py</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create two Hodgkin-Huxley neurons</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>neuron_args <span class="op">=</span> neun_py.HHDoubleConstructorArgs()</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>h1 <span class="op">=</span> neun_py.HHDoubleRK4(neuron_args)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>h2 <span class="op">=</span> neun_py.HHDoubleRK4(neuron_args)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Set parameters for both neurons</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> neuron <span class="kw">in</span> [h1, h2]:</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.cm, <span class="dv">1</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vna, <span class="dv">50</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vk, <span class="op">-</span><span class="dv">77</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vl, <span class="op">-</span><span class="fl">54.387</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gna, <span class="dv">120</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gk, <span class="dv">36</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gl, <span class="fl">0.3</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Set different initial voltages</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>h1.<span class="bu">set</span>(neun_py.HHDoubleVariable.v, <span class="op">-</span><span class="dv">75</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>h2.<span class="bu">set</span>(neun_py.HHDoubleVariable.v, <span class="op">-</span><span class="dv">65</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Create electrical synapse with conductance</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Negative conductance values create the proper coupling</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>synapse <span class="op">=</span> neun_py.ESynHHHHDoubleRK4(</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    h1, neun_py.HHDoubleVariable.v,</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    h2, neun_py.HHDoubleVariable.v,</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.002</span>,  <span class="co"># Conductance from h1 to h2</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.002</span>  <span class="co"># Conductance from h2 to h1</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># ms</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> <span class="dv">100</span>  <span class="co"># ms</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Storage</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>v1_values <span class="op">=</span> []</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>v2_values <span class="op">=</span> []</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>synaptic_currents <span class="op">=</span> []</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Run simulation</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> time <span class="op">&lt;</span> duration:</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step the synapse first (updates coupling)</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    synapse.step(step)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add external input only to first neuron</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    h1.add_synaptic_input(<span class="fl">0.1</span>)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step both neurons</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    h1.step(step)</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    h2.step(step)</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Record data</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    times.append(time)</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    v1_values.append(h1.get(neun_py.HHDoubleVariable.v))</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    v2_values.append(h2.get(neun_py.HHDoubleVariable.v))</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get synaptic current</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    i_syn <span class="op">=</span> synapse.get(neun_py.ESynDoubleVariable.i1)</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    synaptic_currents.append(i_syn)</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    time <span class="op">+=</span> step</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot results</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Membrane potentials</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>ax1.plot(times, v1_values, <span class="st">'b-'</span>, label<span class="op">=</span><span class="st">'Neuron 1 (with input)'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>ax1.plot(times, v2_values, <span class="st">'r-'</span>, label<span class="op">=</span><span class="st">'Neuron 2 (coupled)'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Membrane Potential (mV)'</span>)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Electrical Synapse: Bidirectional Coupling via Gap Junction'</span>)</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>ax1.legend()</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a><span class="co"># Synaptic current</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>ax2.plot(times, synaptic_currents, <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Synaptic Current'</span>)</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Coupling Current Through Gap Junction'</span>)</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'electrical_synapse.pdf'</span>)</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Hands-on
</div>
</div>
<div class="callout-body-container callout-body">
<p>Try modifying the coupling conductanceâ€¦ Are you able to change the synchronization level? ðŸ’»</p>
<details>
<summary>
Solution
</summary>
<ul>
<li>Change <code>0.002</code> to <code>0.001</code> (weaker coupling)</li>
<li>Change to <code>0.003</code> (stronger coupling)</li>
</ul>
<p>You can tell the strength of the coupling from the distance between peaks.</p>
</details>
</div>
</div>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p>Diffusion synapses model <strong>chemical-like coupling</strong> with time-dependent dynamics that approximate neurotransmitter diffusion across the synaptic cleft:</p>
<ul>
<li><strong>Slower transmission</strong>: Time-dependent dynamics</li>
<li><strong>Filtering effects</strong>: Can smooth rapid fluctuations<br>
</li>
<li><strong>Biological realism</strong>: Better models chemical synapses</li>
</ul>
<p><strong>Structure</strong>: <code>DSynN1N2PrecisionIntegrator</code></p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>src/diffusion-synapse.py</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2" data-filename="src/diffusion-synapse.py"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">Two neurons coupled via diffusion synapse</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">Demonstrates chemical-like coupling with dynamics</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> neun_py</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create two Hodgkin-Huxley neurons</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>neuron_args <span class="op">=</span> neun_py.HHDoubleConstructorArgs()</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>h1 <span class="op">=</span> neun_py.HHDoubleRK4(neuron_args)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>h2 <span class="op">=</span> neun_py.HHDoubleRK4(neuron_args)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Set parameters for both neurons</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> neuron <span class="kw">in</span> [h1, h2]:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.cm, <span class="dv">1</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vna, <span class="dv">50</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vk, <span class="op">-</span><span class="dv">77</span>)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vl, <span class="op">-</span><span class="fl">54.387</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gna, <span class="dv">120</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gk, <span class="dv">36</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gl, <span class="fl">0.3</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Set different initial voltages</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>h1.<span class="bu">set</span>(neun_py.HHDoubleVariable.v, <span class="op">-</span><span class="dv">70</span>)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>h2.<span class="bu">set</span>(neun_py.HHDoubleVariable.v, <span class="op">-</span><span class="dv">65</span>)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Create diffusion synapse (chemical-like dynamics)</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>synapse <span class="op">=</span> neun_py.DSynHHHHDoubleRK4(</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    h1, neun_py.HHDoubleVariable.v,</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    h2, neun_py.HHDoubleVariable.v</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># ms</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> <span class="dv">100</span>  <span class="co"># ms</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Storage</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>v1_values <span class="op">=</span> []</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>v2_values <span class="op">=</span> []</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Run simulation</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> time <span class="op">&lt;</span> duration:</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step the synapse first</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    synapse.step(step)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add external input to first neuron</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    h1.add_synaptic_input(<span class="fl">0.12</span>)</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step both neurons</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    h1.step(step)</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    h2.step(step)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Record data</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    times.append(time)</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    v1_values.append(h1.get(neun_py.HHDoubleVariable.v))</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    v2_values.append(h2.get(neun_py.HHDoubleVariable.v))</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    time <span class="op">+=</span> step</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot results</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>plt.plot(times, v1_values, <span class="st">'b-'</span>, label<span class="op">=</span><span class="st">'Neuron 1 (presynaptic)'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>plt.plot(times, v2_values, <span class="st">'r-'</span>, label<span class="op">=</span><span class="st">'Neuron 2 (postsynaptic)'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Membrane Potential (mV)'</span>)</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Diffusion Synapse: Chemical-like Coupling with Dynamics'</span>)</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'diffusion_synapse.pdf'</span>)</span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<!-- 
::: {.callout-note}
## Diffusion vs Electrical

While diffusion synapses include dynamics, they're still simplified compared to full chemical synapses. For more realistic chemical transmission (with neurotransmitter release, receptors, etc.), you'd need additional mechanisms.
::: -->
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Hands-on
</div>
</div>
<div class="callout-body-container callout-body">
<p>Compare the two synapse typesâ€¦ ðŸ’»</p>
<p>Run both examples and observe: - Which shows faster coupling? - Which produces tighter synchronization? - How do the voltage traces differ?</p>
</div>
</div>
</div>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Synapse Naming Convention
</div>
</div>
<div class="callout-body-container callout-body">
<p>Neun follows a systematic naming pattern for synapses:</p>
<pre><code>{SynapseType}{Neuron1Type}{Neuron2Type}{Precision}{Integrator}</code></pre>
<p><strong>Examples</strong>: - <code>ESynHHHHDoubleRK4</code> - Electrical synapse between two HH neurons - <code>DSynHRHRDoubleRK6</code> - Diffusion synapse between two HR neurons<br>
- <code>ESynHHHRFloatRK4</code> - Electrical synapse from HH to HR neuron</p>
<p><strong>Important</strong>: <a href="./step-order.html">Always step synapses <strong>before</strong> stepping neurons</a> in your simulation loop!</p>
</div>
</div>
</section>
<section id="building-neural-networks" class="level2">
<h2 class="anchored" data-anchor-id="building-neural-networks">Building Neural Networks</h2>
<section id="chain-network" class="level3">
<h3 class="anchored" data-anchor-id="chain-network">Chain Network</h3>
<p>Letâ€™s build a simple feedforward chain where activity propagates from one neuron to the next:</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>src/neuron-chain.py</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4" data-filename="src/neuron-chain.py"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">Chain of neurons connected via electrical synapses</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">Demonstrates signal propagation through a network</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> neun_py</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_hh_neuron(v_init<span class="op">=-</span><span class="dv">65</span>):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Helper function to create and initialize an HH neuron"""</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    neuron_args <span class="op">=</span> neun_py.HHDoubleConstructorArgs()</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    neuron <span class="op">=</span> neun_py.HHDoubleRK4(neuron_args)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set parameters</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.cm, <span class="dv">1</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vna, <span class="dv">50</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vk, <span class="op">-</span><span class="dv">77</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vl, <span class="op">-</span><span class="fl">54.387</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gna, <span class="dv">120</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gk, <span class="dv">36</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gl, <span class="fl">0.3</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set initial voltage</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.v, v_init)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.m, <span class="fl">0.05</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.h, <span class="fl">0.6</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.n, <span class="fl">0.3</span>)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> neuron</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a chain of 4 neurons with different initial conditions</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>neurons <span class="op">=</span> [</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    create_hh_neuron(<span class="op">-</span><span class="dv">70</span>),</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    create_hh_neuron(<span class="op">-</span><span class="dv">68</span>),</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    create_hh_neuron(<span class="op">-</span><span class="dv">66</span>),</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    create_hh_neuron(<span class="op">-</span><span class="dv">64</span>)</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Connect them in a chain with electrical synapses</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>synapses <span class="op">=</span> []</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(neurons) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    synapse <span class="op">=</span> neun_py.ESynHHHHDoubleRK4(</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        neurons[i], neun_py.HHDoubleVariable.v,</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>        neurons[i<span class="op">+</span><span class="dv">1</span>], neun_py.HHDoubleVariable.v,</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        <span class="fl">0.002</span>, <span class="fl">0.002</span>  <span class="co"># Bidirectional coupling</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    synapses.append(synapse)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># ms</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> <span class="dv">150</span>  <span class="co"># ms</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Storage</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>voltages <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> neurons]</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a><span class="co"># Run simulation</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> time <span class="op">&lt;</span> duration:</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step all synapses first</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> synapse <span class="kw">in</span> synapses:</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>        synapse.step(step)</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add input only to first neuron</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>    neurons[<span class="dv">0</span>].add_synaptic_input(<span class="fl">0.15</span>)</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step all neurons</span></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> neuron <span class="kw">in</span> neurons:</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>        neuron.step(step)</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Record data</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>    times.append(time)</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, neuron <span class="kw">in</span> <span class="bu">enumerate</span>(neurons):</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>        voltages[i].append(neuron.get(neun_py.HHDoubleVariable.v))</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>    time <span class="op">+=</span> step</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot results</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'red'</span>, <span class="st">'green'</span>, <span class="st">'purple'</span>]</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (v, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(voltages, colors)):</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>    plt.plot(times, v, color<span class="op">=</span>color, label<span class="op">=</span><span class="ss">f'Neuron </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>, </span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>             linewidth<span class="op">=</span><span class="fl">1.5</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Membrane Potential (mV)'</span>)</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Signal Propagation Through a Chain of Coupled Neurons'</span>)</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'neuron_chain.pdf'</span>)</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p><strong>Observation</strong>: Notice how the spike travels through the chain with some delay. The coupling strength determines how effectively the signal propagates.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Hands-on
</div>
</div>
<div class="callout-body-container callout-body">
<p>Experiment with the chainâ€¦ ðŸ’»</p>
<ol type="1">
<li>Change the coupling strength (currently <code>-0.002</code>)</li>
<li>Add input to the last neuron instead of the first</li>
<li>Add more neurons to the chain (change <code>4</code> to <code>6</code> or <code>8</code>)</li>
</ol>
<p>Whatâ€™s the maximum chain length before signal dies out?</p>
</div>
</div>
</section>
<section id="all-to-all-network" class="level3">
<h3 class="anchored" data-anchor-id="all-to-all-network">All-to-All Network</h3>
<p>In many brain regions, neurons are densely interconnected. Letâ€™s simulate this:</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>src/population-rate.py</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5" data-filename="src/population-rate.py"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">Population firing rate analysis</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">Compute and visualize average network activity</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> neun_py</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_hh_neuron(v_init<span class="op">=-</span><span class="dv">65</span>):</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create and initialize an HH neuron"""</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    neuron_args <span class="op">=</span> neun_py.HHDoubleConstructorArgs()</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    neuron <span class="op">=</span> neun_py.HHDoubleRK4(neuron_args)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.cm, <span class="dv">1</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vna, <span class="dv">50</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vk, <span class="op">-</span><span class="dv">77</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vl, <span class="op">-</span><span class="fl">54.387</span>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gna, <span class="dv">120</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gk, <span class="dv">36</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gl, <span class="fl">0.3</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.v, v_init)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.m, <span class="fl">0.05</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.h, <span class="fl">0.6</span>)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.n, <span class="fl">0.3</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> neuron</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Create network of 10 neurons</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>n_neurons <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>neurons <span class="op">=</span> [create_hh_neuron(<span class="op">-</span><span class="dv">65</span> <span class="op">+</span> np.random.randn()<span class="op">*</span><span class="dv">3</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_neurons)]</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Create all-to-all connectivity with weak coupling</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>synapses <span class="op">=</span> []</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>coupling_strength <span class="op">=</span> <span class="op">-</span><span class="fl">0.0005</span>  <span class="co"># Weak coupling</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_neurons):</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n_neurons):</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        synapse <span class="op">=</span> neun_py.ESynHHHHDoubleRK4(</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>            neurons[i], neun_py.HHDoubleVariable.v,</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>            neurons[j], neun_py.HHDoubleVariable.v,</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>            coupling_strength, coupling_strength</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        synapses.append(synapse)</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># ms</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> <span class="dv">200</span>  <span class="co"># ms</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Storage</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>voltages <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_neurons)]</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>population_voltage <span class="op">=</span> []</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Run simulation</span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> time <span class="op">&lt;</span> duration:</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step all synapses</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> synapse <span class="kw">in</span> synapses:</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>        synapse.step(step)</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add external input with some variability</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, neuron <span class="kw">in</span> <span class="bu">enumerate</span>(neurons):</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Random input to create heterogeneous activity</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>        input_current <span class="op">=</span> <span class="fl">0.10</span> <span class="op">+</span> np.random.randn() <span class="op">*</span> <span class="fl">0.01</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>        neuron.add_synaptic_input(input_current)</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step neurons</span></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> neuron <span class="kw">in</span> neurons:</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>        neuron.step(step)</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Record data</span></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>    times.append(time)</span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>    v_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, neuron <span class="kw">in</span> <span class="bu">enumerate</span>(neurons):</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> neuron.get(neun_py.HHDoubleVariable.v)</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>        voltages[i].append(v)</span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>        v_sum <span class="op">+=</span> v</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Population mean voltage</span></span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>    population_voltage.append(v_sum <span class="op">/</span> n_neurons)</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>    time <span class="op">+=</span> step</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute population firing rate using sliding window</span></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>window_size <span class="op">=</span> <span class="dv">5</span>  <span class="co"># ms</span></span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>window_samples <span class="op">=</span> <span class="bu">int</span>(window_size <span class="op">/</span> step)</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>firing_rate <span class="op">=</span> []</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>rate_times <span class="op">=</span> []</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>spike_threshold <span class="op">=</span> <span class="dv">0</span>  <span class="co"># mV</span></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(times) <span class="op">-</span> window_samples, window_samples<span class="op">//</span><span class="dv">2</span>):</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>    spike_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>    window_time <span class="op">=</span> times[i <span class="op">+</span> window_samples<span class="op">//</span><span class="dv">2</span>]</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_neurons):</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Count threshold crossings in window</span></span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i, <span class="bu">min</span>(i <span class="op">+</span> window_samples, <span class="bu">len</span>(voltages[j]))):</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> k <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> voltages[j][k] <span class="op">&gt;</span> spike_threshold <span class="kw">and</span> voltages[j][k<span class="op">-</span><span class="dv">1</span>] <span class="op">&lt;=</span> spike_threshold:</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>                spike_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to firing rate (Hz)</span></span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a>    rate <span class="op">=</span> (spike_count <span class="op">/</span> n_neurons) <span class="op">/</span> (window_size <span class="op">/</span> <span class="dv">1000</span>)</span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>    firing_rate.append(rate)</span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>    rate_times.append(window_time)</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot results</span></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a><span class="co"># Individual neurons</span></span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> plt.cm.viridis(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="bu">min</span>(<span class="dv">5</span>, n_neurons)))</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">5</span>, n_neurons)):  <span class="co"># Show first 5 neurons</span></span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>    ax1.plot(times, voltages[i], color<span class="op">=</span>colors[i], </span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a>             label<span class="op">=</span><span class="ss">f'Neuron </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Membrane Potential (mV)'</span>)</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Individual Neuron Activity (subset)'</span>)</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>ax1.legend(loc<span class="op">=</span><span class="st">'upper right'</span>, ncol<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a><span class="co"># Population average voltage</span></span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a>ax2.plot(times, population_voltage, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Mean Voltage (mV)'</span>)</span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Population Average Membrane Potential'</span>)</span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a><span class="co"># Population firing rate</span></span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>ax3.plot(rate_times, firing_rate, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>ax3.set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>ax3.set_ylabel(<span class="st">'Firing Rate (Hz)'</span>)</span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a>ax3.set_title(<span class="ss">f'Population Firing Rate (window: </span><span class="sc">{</span>window_size<span class="sc">}</span><span class="ss"> ms)'</span>)</span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>ax3.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'population_rate.pdf'</span>)</span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a><span class="co"># Print statistics</span></span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Network Statistics:"</span>)</span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Number of neurons: </span><span class="sc">{</span>n_neurons<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Number of synapses: </span><span class="sc">{</span><span class="bu">len</span>(synapses)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Mean firing rate: </span><span class="sc">{</span>np<span class="sc">.</span>mean(firing_rate)<span class="sc">:.2f}</span><span class="ss"> Hz"</span>)</span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Peak firing rate: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">max</span>(firing_rate)<span class="sc">:.2f}</span><span class="ss"> Hz"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>All-to-All Connectivity
</div>
</div>
<div class="callout-body-container callout-body">
<p>With <span class="math inline">\(N\)</span> neurons, an all-to-all network has: <span class="math display">\[\text{Number of synapses} = \frac{N(N-1)}{2}\]</span></p>
<p>This scales as <span class="math inline">\(O(N^2)\)</span>, so computation grows quickly with network size!</p>
</div>
</div>
</section>
</section>
<section id="visualizing-network-activity" class="level2">
<h2 class="anchored" data-anchor-id="visualizing-network-activity">Visualizing Network Activity</h2>
<p>Understanding network behavior requires appropriate visualization tools:</p>
<section id="raster-plots" class="level3">
<h3 class="anchored" data-anchor-id="raster-plots">Raster Plots</h3>
<p>Raster plots show <strong>spike times</strong> for all neurons, revealing temporal patterns:</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>src/raster-plot.py</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6" data-filename="src/raster-plot.py"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">Network activity visualization with raster plot</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">Shows spike times for multiple neurons</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> neun_py</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_hh_neuron(v_init<span class="op">=-</span><span class="dv">65</span>):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create and initialize an HH neuron"""</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    neuron_args <span class="op">=</span> neun_py.HHDoubleConstructorArgs()</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    neuron <span class="op">=</span> neun_py.HHDoubleRK4(neuron_args)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.cm, <span class="dv">1</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vna, <span class="dv">50</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vk, <span class="op">-</span><span class="dv">77</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vl, <span class="op">-</span><span class="fl">54.387</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gna, <span class="dv">120</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gk, <span class="dv">36</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gl, <span class="fl">0.3</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.v, v_init)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.m, <span class="fl">0.05</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.h, <span class="fl">0.6</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.n, <span class="fl">0.3</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> neuron</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Create 5 neurons</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>n_neurons <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>neurons <span class="op">=</span> [create_hh_neuron(<span class="op">-</span><span class="dv">65</span> <span class="op">+</span> i<span class="op">*</span><span class="dv">2</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_neurons)]</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Connect in a simple network (each to next)</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>synapses <span class="op">=</span> []</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_neurons <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    synapse <span class="op">=</span> neun_py.ESynHHHHDoubleRK4(</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        neurons[i], neun_py.HHDoubleVariable.v,</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>        neurons[i<span class="op">+</span><span class="dv">1</span>], neun_py.HHDoubleVariable.v,</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span><span class="fl">0.001</span>, <span class="op">-</span><span class="fl">0.001</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    synapses.append(synapse)</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># ms</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> <span class="dv">200</span>  <span class="co"># ms</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Storage for spike detection</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>spike_threshold <span class="op">=</span> <span class="dv">0</span>  <span class="co"># mV</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>spike_times <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_neurons)]</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>was_below_threshold <span class="op">=</span> [<span class="va">True</span>] <span class="op">*</span> n_neurons</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>voltages <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_neurons)]</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Run simulation</span></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> time <span class="op">&lt;</span> duration:</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step synapses</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> synapse <span class="kw">in</span> synapses:</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>        synapse.step(step)</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add different inputs to create varied activity</span></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, neuron <span class="kw">in</span> <span class="bu">enumerate</span>(neurons):</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># First neuron gets constant input, others get less</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>        input_current <span class="op">=</span> <span class="fl">0.12</span> <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="fl">0.08</span> <span class="cf">if</span> i <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="fl">0.0</span></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>        neuron.add_synaptic_input(input_current)</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step neurons</span></span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> neuron <span class="kw">in</span> neurons:</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>        neuron.step(step)</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Record and detect spikes</span></span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>    times.append(time)</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, neuron <span class="kw">in</span> <span class="bu">enumerate</span>(neurons):</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> neuron.get(neun_py.HHDoubleVariable.v)</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>        voltages[i].append(v)</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Spike detection: crossing threshold from below</span></span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> was_below_threshold[i] <span class="kw">and</span> v <span class="op">&gt;</span> spike_threshold:</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>            spike_times[i].append(time)</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>            was_below_threshold[i] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> v <span class="op">&lt;</span> spike_threshold:</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>            was_below_threshold[i] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>    time <span class="op">+=</span> step</span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a><span class="co"># Create figure with two subplots</span></span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a><span class="co"># Raster plot</span></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, spikes <span class="kw">in</span> <span class="bu">enumerate</span>(spike_times):</span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>    ax1.scatter(spikes, [i] <span class="op">*</span> <span class="bu">len</span>(spikes), c<span class="op">=</span><span class="st">'black'</span>, marker<span class="op">=</span><span class="st">'|'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Neuron ID'</span>)</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Network Activity: Raster Plot'</span>)</span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(<span class="op">-</span><span class="fl">0.5</span>, n_neurons <span class="op">-</span> <span class="fl">0.5</span>)</span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a>ax1.set_yticks(<span class="bu">range</span>(n_neurons))</span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a><span class="co"># Voltage traces (subset for clarity)</span></span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> plt.cm.viridis(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, n_neurons))</span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_neurons):</span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a>    ax2.plot(times, voltages[i], color<span class="op">=</span>colors[i], </span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a>             label<span class="op">=</span><span class="ss">f'Neuron </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span>, linewidth<span class="op">=</span><span class="fl">1.0</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Membrane Potential (mV)'</span>)</span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Network Activity: Voltage Traces'</span>)</span>
<span id="cb6-111"><a href="#cb6-111" aria-hidden="true" tabindex="-1"></a>ax2.legend(loc<span class="op">=</span><span class="st">'upper right'</span>, ncol<span class="op">=</span>n_neurons)</span>
<span id="cb6-112"><a href="#cb6-112" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb6-113"><a href="#cb6-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-114"><a href="#cb6-114" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb6-115"><a href="#cb6-115" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'raster_plot.pdf'</span>)</span>
<span id="cb6-116"><a href="#cb6-116" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb6-117"><a href="#cb6-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-118"><a href="#cb6-118" aria-hidden="true" tabindex="-1"></a><span class="co"># Print spike statistics</span></span>
<span id="cb6-119"><a href="#cb6-119" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Spike Statistics:"</span>)</span>
<span id="cb6-120"><a href="#cb6-120" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, spikes <span class="kw">in</span> <span class="bu">enumerate</span>(spike_times):</span>
<span id="cb6-121"><a href="#cb6-121" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Neuron </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span><span class="bu">len</span>(spikes)<span class="sc">}</span><span class="ss"> spikes"</span>)</span>
<span id="cb6-122"><a href="#cb6-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(spikes) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb6-123"><a href="#cb6-123" aria-hidden="true" tabindex="-1"></a>        isis <span class="op">=</span> np.diff(spikes)</span>
<span id="cb6-124"><a href="#cb6-124" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"    Mean ISI: </span><span class="sc">{</span>np<span class="sc">.</span>mean(isis)<span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb6-125"><a href="#cb6-125" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"    Firing rate: </span><span class="sc">{</span><span class="bu">len</span>(spikes)<span class="op">/</span>(duration<span class="op">/</span><span class="dv">1000</span>)<span class="sc">:.2f}</span><span class="ss"> Hz"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p><strong>What to look for</strong>: - <strong>Synchrony</strong>: Vertical alignment of spikes - <strong>Propagation</strong>: Diagonal patterns - <strong>Rhythms</strong>: Regular spacing</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Hands-on
</div>
</div>
<div class="callout-body-container callout-body">
<p>Analyze the raster plotâ€¦ ðŸ’»</p>
<ul>
<li>Can you identify synchronized events?</li>
<li>Do you see traveling waves?</li>
<li>Try increasing the coupling strength - what changes?</li>
</ul>
</div>
</div>
</section>
<section id="population-firing-rate" class="level3">
<h3 class="anchored" data-anchor-id="population-firing-rate">Population Firing Rate</h3>
<p>The population firing rate captures <strong>collective activity</strong>:</p>
<p>Already shown in the all-to-all network example above! The population firing rate is computed using a sliding window to count spikes across the network.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Computing Firing Rates
</div>
</div>
<div class="callout-body-container callout-body">
<p>Common approaches: 1. <strong>Spike counting</strong>: Count spikes in time window, divide by window size 2. <strong>Instantaneous rate</strong>: Inverse of inter-spike interval 3. <strong>Kernel smoothing</strong>: Convolve spike train with Gaussian</p>
<p>Each has trade-offs between temporal resolution and noise!</p>
</div>
</div>
</section>
</section>
<section id="network-synchronization" class="level2">
<h2 class="anchored" data-anchor-id="network-synchronization">Network Synchronization</h2>
<p>How coupled neurons synchronize depends on the <strong>coupling strength</strong>:</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>src/coupling-strength.py</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7" data-filename="src/coupling-strength.py"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">Explore effect of coupling strength on synchronization</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">Demonstrates how synaptic conductance affects network dynamics</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> neun_py</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_hh_neuron(v_init<span class="op">=-</span><span class="dv">65</span>):</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create and initialize an HH neuron"""</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    neuron_args <span class="op">=</span> neun_py.HHDoubleConstructorArgs()</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    neuron <span class="op">=</span> neun_py.HHDoubleRK4(neuron_args)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.cm, <span class="dv">1</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vna, <span class="dv">50</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vk, <span class="op">-</span><span class="dv">77</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.vl, <span class="op">-</span><span class="fl">54.387</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gna, <span class="dv">120</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gk, <span class="dv">36</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HHDoubleParameter.gl, <span class="fl">0.3</span> <span class="op">*</span> <span class="fl">7.854e-3</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.v, v_init)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.m, <span class="fl">0.05</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.h, <span class="fl">0.6</span>)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HHDoubleVariable.n, <span class="fl">0.3</span>)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> neuron</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_simulation(coupling_conductance):</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Run simulation with given coupling strength"""</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create two neurons with different initial conditions</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    h1 <span class="op">=</span> create_hh_neuron(<span class="op">-</span><span class="dv">75</span>)</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    h2 <span class="op">=</span> create_hh_neuron(<span class="op">-</span><span class="dv">65</span>)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create synapse with specified coupling</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    synapse <span class="op">=</span> neun_py.ESynHHHHDoubleRK4(</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>        h1, neun_py.HHDoubleVariable.v,</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>        h2, neun_py.HHDoubleVariable.v,</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span>coupling_conductance, <span class="op">-</span>coupling_conductance</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulation</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    step <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    duration <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    v1_vals <span class="op">=</span> []</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    v2_vals <span class="op">=</span> []</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> time <span class="op">&lt;</span> duration:</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>        synapse.step(step)</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>        h1.add_synaptic_input(<span class="fl">0.1</span>)</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>        h2.add_synaptic_input(<span class="fl">0.08</span>)</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>        h1.step(step)</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>        h2.step(step)</span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>        v1_vals.append(h1.get(neun_py.HHDoubleVariable.v))</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>        v2_vals.append(h2.get(neun_py.HHDoubleVariable.v))</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>        time <span class="op">+=</span> step</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(v1_vals), np.array(v2_vals)</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_synchronization(v1, v2):</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute correlation coefficient as measure of synchronization"""</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.corrcoef(v1, v2)[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a><span class="co"># Test different coupling strengths</span></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>conductances <span class="op">=</span> np.linspace(<span class="fl">0.0001</span>, <span class="fl">0.01</span>, <span class="dv">15</span>)</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>sync_values <span class="op">=</span> []</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Computing synchronization for different coupling strengths..."</span>)</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> g <span class="kw">in</span> conductances:</span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>    v1, v2 <span class="op">=</span> run_simulation(g)</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>    sync <span class="op">=</span> compute_synchronization(v1, v2)</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>    sync_values.append(sync)</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  g = </span><span class="sc">{</span>g<span class="sc">:.4f}</span><span class="ss">: sync = </span><span class="sc">{</span>sync<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a><span class="co"># Create visualization</span></span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">4</span>))</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a><span class="co"># Example traces for weak, medium, and strong coupling</span></span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a>example_conductances <span class="op">=</span> [<span class="fl">0.0001</span>, <span class="fl">0.005</span>, <span class="fl">0.01</span>]</span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>example_labels <span class="op">=</span> [<span class="st">'Weak'</span>, <span class="st">'Medium'</span>, <span class="st">'Strong'</span>]</span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'red'</span>, <span class="st">'orange'</span>, <span class="st">'green'</span>]</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (g, label, color) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(example_conductances, example_labels, colors)):</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a>    v1, v2 <span class="op">=</span> run_simulation(g)</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>    times <span class="op">=</span> np.arange(<span class="bu">len</span>(v1)) <span class="op">*</span> <span class="fl">0.001</span></span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> ax1 <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> (ax2 <span class="cf">if</span> i <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> ax3)</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a>    ax.plot(times, v1, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span><span class="st">'Neuron 1'</span>)</span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a>    ax.plot(times, v2, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span><span class="st">'Neuron 2'</span>)</span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Voltage (mV)'</span>)</span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f'</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss"> Coupling (g=</span><span class="sc">{</span>g<span class="sc">:.4f}</span><span class="ss">)'</span>)</span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>    ax.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'coupling_examples.pdf'</span>)</span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot synchronization vs coupling strength</span></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a>plt.plot(conductances, sync_values, <span class="st">'o-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, markersize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Coupling Conductance'</span>)</span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Synchronization (Correlation)'</span>)</span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Network Synchronization vs Coupling Strength'</span>)</span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'coupling_strength.pdf'</span>)</span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Synchronization increases with coupling strength!"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Synchronization Mechanisms
</div>
</div>
<div class="callout-body-container callout-body">
<p>Electrical synapses promote synchronization through:</p>
<ol type="1">
<li><strong>Direct coupling</strong>: Voltage differences drive equalizing currents</li>
<li><strong>Phase locking</strong>: Neurons adjust their firing times to match</li>
<li><strong>Resonance</strong>: Coupling most effective near natural frequencies</li>
</ol>
<p>But too much synchronization can be pathological (e.g., epilepsy)!</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Hands-on
</div>
</div>
<div class="callout-body-container callout-body">
<p>Explore synchronizationâ€¦ ðŸ’»</p>
<ol type="1">
<li>What coupling strength gives 50% synchronization?</li>
<li>Is there a threshold effect?</li>
<li>Try different initial voltage differences - does it matter?</li>
</ol>
</div>
</div>
</section>
<section id="central-pattern-generators-cpgs" class="level2">
<h2 class="anchored" data-anchor-id="central-pattern-generators-cpgs">Central Pattern Generators (CPGs)</h2>
<p>CPGs are neural circuits that produce <strong>rhythmic patterns</strong> without rhythmic input. Theyâ€™re essential for locomotion, breathing, and other rhythmic behaviors.</p>
<p>Key features of CPGs: - <strong>Intrinsic rhythmicity</strong>: Generated by network dynamics, not input - <strong>Phase relationships</strong>: Neurons fire in specific temporal order - <strong>Robustness</strong>: Maintain rhythm despite perturbations</p>
<section id="reciprocal-inhibition-model" class="level3">
<h3 class="anchored" data-anchor-id="reciprocal-inhibition-model">Reciprocal Inhibition Model</h3>
<p>A classic CPG uses two neurons with mutual inhibition creating alternating bursts:</p>
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>src/cpg-analysis.py</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8" data-filename="src/cpg-analysis.py"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">Central Pattern Generator (CPG) Analysis</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">Demonstrates rhythmic activity and phase relationships</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> neun_py</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_hr_neuron(I_ext<span class="op">=</span><span class="fl">3.0</span>, ini_x<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create Hindmarsh-Rose neuron (good for rhythmic activity)"""</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    neuron_args <span class="op">=</span> neun_py.HRDoubleConstructorArgs()</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    neuron <span class="op">=</span> neun_py.HRDoubleRK4(neuron_args)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># HR parameters for bursting</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.e, I_ext)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.a, <span class="fl">1.0</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.b, <span class="fl">3.0</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.c, <span class="fl">1.0</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.d, <span class="fl">5.0</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.mu, <span class="fl">0.006</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.S, <span class="fl">4.0</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.xr, <span class="op">-</span><span class="fl">1.6</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    neuron.set_param(neun_py.HRDoubleParameter.vh, <span class="dv">1</span>)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initial conditions</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HRDoubleVariable.x, ini_x)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HRDoubleVariable.y, <span class="op">-</span><span class="fl">10.0</span>)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    neuron.<span class="bu">set</span>(neun_py.HRDoubleVariable.z, <span class="fl">0.0</span>)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> neuron</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Create two HR neurons with reciprocal inhibition (CPG configuration)</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>n1 <span class="op">=</span> create_hr_neuron(<span class="fl">3.0</span>, <span class="op">-</span><span class="fl">1.5</span>)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>n2 <span class="op">=</span> create_hr_neuron(<span class="fl">3.0</span>, <span class="dv">0</span>)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Reciprocal coupling (simulating mutual inhibition)</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>s12 <span class="op">=</span> neun_py.ESynHRHRDoubleRK4(</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>    n1, neun_py.HRDoubleVariable.x,</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    n2, neun_py.HRDoubleVariable.x,</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">-</span><span class="fl">0.75</span>, <span class="op">-</span><span class="fl">0.75</span>  <span class="co"># Inhibitory-like coupling</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation parameters</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> <span class="fl">0.01</span>  <span class="co"># ms</span></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> <span class="dv">1000</span>  <span class="co"># ms (longer to see rhythm)</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Storage</span></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> []</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>x1_values <span class="op">=</span> []</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>x2_values <span class="op">=</span> []</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Run simulation</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> time <span class="op">&lt;</span> duration:</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>    s12.step(step)</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>    n1.step(step)</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>    n2.step(step)</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>    times.append(time)</span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>    x1_values.append(n1.get(neun_py.HRDoubleVariable.x))</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>    x2_values.append(n2.get(neun_py.HRDoubleVariable.x))</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>    time <span class="op">+=</span> step</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to numpy arrays</span></span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> np.array(times)</span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>x1_values <span class="op">=</span> np.array(x1_values)</span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>x2_values <span class="op">=</span> np.array(x2_values)</span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>plt.plot(times, x1_values, <span class="st">'b-'</span>, label<span class="op">=</span><span class="st">'Neuron 1'</span>)</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a>plt.plot(times, x2_values, <span class="st">'r-'</span>, label<span class="op">=</span><span class="st">'Neuron 2'</span>)</span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect burst peaks (local maxima above threshold)</span></span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> detect_bursts(signal, threshold<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>    bursts <span class="op">=</span> []</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(signal)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> signal[i] <span class="op">&gt;</span> threshold <span class="kw">and</span> signal[i] <span class="op">&gt;</span> signal[i<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> signal[i] <span class="op">&gt;</span> signal[i<span class="op">+</span><span class="dv">1</span>]:</span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>            bursts.append(i)</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(bursts)</span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>bursts1 <span class="op">=</span> detect_bursts(x1_values, threshold<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>bursts2 <span class="op">=</span> detect_bursts(x2_values, threshold<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute inter-burst intervals (IBIs)</span></span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_ibis(burst_indices, times):</span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(burst_indices) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array([])</span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a>    burst_times <span class="op">=</span> times[burst_indices]</span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.diff(burst_times)</span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a>ibi1 <span class="op">=</span> compute_ibis(bursts1, times)</span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a>ibi2 <span class="op">=</span> compute_ibis(bursts2, times)</span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute phase difference (time lag between bursts)</span></span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_phase_lag(bursts1, bursts2, times):</span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(bursts1) <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> <span class="bu">len</span>(bursts2) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a>    phase_lags <span class="op">=</span> []</span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> b1 <span class="kw">in</span> bursts1:</span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find nearest burst in neuron 2</span></span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(bursts2) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a>            nearest <span class="op">=</span> bursts2[np.argmin(np.<span class="bu">abs</span>(bursts2 <span class="op">-</span> b1))]</span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a>            lag <span class="op">=</span> times[nearest] <span class="op">-</span> times[b1]</span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a>            phase_lags.append(lag)</span>
<span id="cb8-109"><a href="#cb8-109" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-110"><a href="#cb8-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(phase_lags)</span>
<span id="cb8-111"><a href="#cb8-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-112"><a href="#cb8-112" aria-hidden="true" tabindex="-1"></a>phase_lags <span class="op">=</span> compute_phase_lag(bursts1, bursts2, times)</span>
<span id="cb8-113"><a href="#cb8-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-114"><a href="#cb8-114" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualization</span></span>
<span id="cb8-115"><a href="#cb8-115" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">10</span>))</span>
<span id="cb8-116"><a href="#cb8-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-117"><a href="#cb8-117" aria-hidden="true" tabindex="-1"></a><span class="co"># Activity traces</span></span>
<span id="cb8-118"><a href="#cb8-118" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, (<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb8-119"><a href="#cb8-119" aria-hidden="true" tabindex="-1"></a>ax1.plot(times, x1_values, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Neuron 1'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb8-120"><a href="#cb8-120" aria-hidden="true" tabindex="-1"></a>ax1.plot(times, x2_values, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Neuron 2'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb8-121"><a href="#cb8-121" aria-hidden="true" tabindex="-1"></a>ax1.plot(times[bursts1], x1_values[bursts1], <span class="st">'bo'</span>, markersize<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb8-122"><a href="#cb8-122" aria-hidden="true" tabindex="-1"></a>ax1.plot(times[bursts2], x2_values[bursts2], <span class="st">'ro'</span>, markersize<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb8-123"><a href="#cb8-123" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb8-124"><a href="#cb8-124" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Membrane Potential'</span>)</span>
<span id="cb8-125"><a href="#cb8-125" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Central Pattern Generator: Rhythmic Activity'</span>)</span>
<span id="cb8-126"><a href="#cb8-126" aria-hidden="true" tabindex="-1"></a>ax1.legend()</span>
<span id="cb8-127"><a href="#cb8-127" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-128"><a href="#cb8-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-129"><a href="#cb8-129" aria-hidden="true" tabindex="-1"></a><span class="co"># Raster plot</span></span>
<span id="cb8-130"><a href="#cb8-130" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb8-131"><a href="#cb8-131" aria-hidden="true" tabindex="-1"></a>ax2.scatter(times[bursts1], np.ones_like(bursts1), c<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'|'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb8-132"><a href="#cb8-132" aria-hidden="true" tabindex="-1"></a>ax2.scatter(times[bursts2], np.zeros_like(bursts2), c<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'|'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb8-133"><a href="#cb8-133" aria-hidden="true" tabindex="-1"></a>ax2.set_yticks([<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb8-134"><a href="#cb8-134" aria-hidden="true" tabindex="-1"></a>ax2.set_yticklabels([<span class="st">'Neuron 2'</span>, <span class="st">'Neuron 1'</span>])</span>
<span id="cb8-135"><a href="#cb8-135" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb8-136"><a href="#cb8-136" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Burst Timing (Raster)'</span>)</span>
<span id="cb8-137"><a href="#cb8-137" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-138"><a href="#cb8-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-139"><a href="#cb8-139" aria-hidden="true" tabindex="-1"></a><span class="co"># Inter-burst intervals</span></span>
<span id="cb8-140"><a href="#cb8-140" aria-hidden="true" tabindex="-1"></a>ax3 <span class="op">=</span> plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb8-141"><a href="#cb8-141" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(ibi1) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-142"><a href="#cb8-142" aria-hidden="true" tabindex="-1"></a>    ax3.plot(ibi1, <span class="st">'bo-'</span>, label<span class="op">=</span><span class="st">'Neuron 1'</span>, markersize<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb8-143"><a href="#cb8-143" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(ibi2) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-144"><a href="#cb8-144" aria-hidden="true" tabindex="-1"></a>    ax3.plot(ibi2, <span class="st">'ro-'</span>, label<span class="op">=</span><span class="st">'Neuron 2'</span>, markersize<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb8-145"><a href="#cb8-145" aria-hidden="true" tabindex="-1"></a>ax3.set_xlabel(<span class="st">'Burst Number'</span>)</span>
<span id="cb8-146"><a href="#cb8-146" aria-hidden="true" tabindex="-1"></a>ax3.set_ylabel(<span class="st">'Inter-Burst Interval (ms)'</span>)</span>
<span id="cb8-147"><a href="#cb8-147" aria-hidden="true" tabindex="-1"></a>ax3.set_title(<span class="st">'Rhythm Regularity'</span>)</span>
<span id="cb8-148"><a href="#cb8-148" aria-hidden="true" tabindex="-1"></a>ax3.legend()</span>
<span id="cb8-149"><a href="#cb8-149" aria-hidden="true" tabindex="-1"></a>ax3.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-150"><a href="#cb8-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-151"><a href="#cb8-151" aria-hidden="true" tabindex="-1"></a><span class="co"># Phase relationship</span></span>
<span id="cb8-152"><a href="#cb8-152" aria-hidden="true" tabindex="-1"></a>ax4 <span class="op">=</span> plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>)</span>
<span id="cb8-153"><a href="#cb8-153" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(phase_lags) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-154"><a href="#cb8-154" aria-hidden="true" tabindex="-1"></a>    ax4.hist(phase_lags, bins<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">'purple'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb8-155"><a href="#cb8-155" aria-hidden="true" tabindex="-1"></a>    ax4.axvline(np.mean(phase_lags), color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, </span>
<span id="cb8-156"><a href="#cb8-156" aria-hidden="true" tabindex="-1"></a>                linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f'Mean: </span><span class="sc">{</span>np<span class="sc">.</span>mean(phase_lags)<span class="sc">:.1f}</span><span class="ss"> ms'</span>)</span>
<span id="cb8-157"><a href="#cb8-157" aria-hidden="true" tabindex="-1"></a>ax4.set_xlabel(<span class="st">'Phase Lag (ms)'</span>)</span>
<span id="cb8-158"><a href="#cb8-158" aria-hidden="true" tabindex="-1"></a>ax4.set_ylabel(<span class="st">'Count'</span>)</span>
<span id="cb8-159"><a href="#cb8-159" aria-hidden="true" tabindex="-1"></a>ax4.set_title(<span class="st">'Phase Relationship Between Neurons'</span>)</span>
<span id="cb8-160"><a href="#cb8-160" aria-hidden="true" tabindex="-1"></a>ax4.legend()</span>
<span id="cb8-161"><a href="#cb8-161" aria-hidden="true" tabindex="-1"></a>ax4.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-162"><a href="#cb8-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-163"><a href="#cb8-163" aria-hidden="true" tabindex="-1"></a><span class="co"># Zoomed view</span></span>
<span id="cb8-164"><a href="#cb8-164" aria-hidden="true" tabindex="-1"></a>ax5 <span class="op">=</span> plt.subplot(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">6</span>)</span>
<span id="cb8-165"><a href="#cb8-165" aria-hidden="true" tabindex="-1"></a>zoom_start <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(times) <span class="op">*</span> <span class="fl">0.3</span>)</span>
<span id="cb8-166"><a href="#cb8-166" aria-hidden="true" tabindex="-1"></a>zoom_end <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(times) <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb8-167"><a href="#cb8-167" aria-hidden="true" tabindex="-1"></a>ax5.plot(times[zoom_start:zoom_end], x1_values[zoom_start:zoom_end], </span>
<span id="cb8-168"><a href="#cb8-168" aria-hidden="true" tabindex="-1"></a>         <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Neuron 1'</span>)</span>
<span id="cb8-169"><a href="#cb8-169" aria-hidden="true" tabindex="-1"></a>ax5.plot(times[zoom_start:zoom_end], x2_values[zoom_start:zoom_end], </span>
<span id="cb8-170"><a href="#cb8-170" aria-hidden="true" tabindex="-1"></a>         <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Neuron 2'</span>)</span>
<span id="cb8-171"><a href="#cb8-171" aria-hidden="true" tabindex="-1"></a>ax5.set_xlabel(<span class="st">'Time (ms)'</span>)</span>
<span id="cb8-172"><a href="#cb8-172" aria-hidden="true" tabindex="-1"></a>ax5.set_ylabel(<span class="st">'Membrane Potential'</span>)</span>
<span id="cb8-173"><a href="#cb8-173" aria-hidden="true" tabindex="-1"></a>ax5.set_title(<span class="st">'Zoomed View: Alternating Bursts'</span>)</span>
<span id="cb8-174"><a href="#cb8-174" aria-hidden="true" tabindex="-1"></a>ax5.legend()</span>
<span id="cb8-175"><a href="#cb8-175" aria-hidden="true" tabindex="-1"></a>ax5.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-176"><a href="#cb8-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-177"><a href="#cb8-177" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-178"><a href="#cb8-178" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'cpg_analysis.pdf'</span>)</span>
<span id="cb8-179"><a href="#cb8-179" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb8-180"><a href="#cb8-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-181"><a href="#cb8-181" aria-hidden="true" tabindex="-1"></a><span class="co"># Print statistics</span></span>
<span id="cb8-182"><a href="#cb8-182" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"CPG Statistics:"</span>)</span>
<span id="cb8-183"><a href="#cb8-183" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Neuron 1: </span><span class="sc">{</span><span class="bu">len</span>(bursts1)<span class="sc">}</span><span class="ss"> bursts"</span>)</span>
<span id="cb8-184"><a href="#cb8-184" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Neuron 2: </span><span class="sc">{</span><span class="bu">len</span>(bursts2)<span class="sc">}</span><span class="ss"> bursts"</span>)</span>
<span id="cb8-185"><a href="#cb8-185" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(ibi1) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-186"><a href="#cb8-186" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Mean IBI Neuron 1: </span><span class="sc">{</span>np<span class="sc">.</span>mean(ibi1)<span class="sc">:.2f}</span><span class="ss"> Â± </span><span class="sc">{</span>np<span class="sc">.</span>std(ibi1)<span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb8-187"><a href="#cb8-187" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(ibi2) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-188"><a href="#cb8-188" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Mean IBI Neuron 2: </span><span class="sc">{</span>np<span class="sc">.</span>mean(ibi2)<span class="sc">:.2f}</span><span class="ss"> Â± </span><span class="sc">{</span>np<span class="sc">.</span>std(ibi2)<span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span>
<span id="cb8-189"><a href="#cb8-189" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(phase_lags) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb8-190"><a href="#cb8-190" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Mean phase lag: </span><span class="sc">{</span>np<span class="sc">.</span>mean(phase_lags)<span class="sc">:.2f}</span><span class="ss"> Â± </span><span class="sc">{</span>np<span class="sc">.</span>std(phase_lags)<span class="sc">:.2f}</span><span class="ss"> ms"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>CPG Analysis Metrics
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Inter-Burst Interval (IBI)</strong>: Time between successive bursts in one neuron - Measures rhythm regularity - CV of IBI &lt; 0.1 indicates regular rhythm</p>
<p><strong>Phase Lag</strong>: Time difference between corresponding events in two neurons - Characterizes coordination - For anti-phase: lag â‰ˆ half the cycle period</p>
<p><strong>Duty Cycle</strong>: Fraction of time neuron is active - Active time / cycle period - Typical values: 0.3-0.5 for alternating rhythms</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Hands-on
</div>
</div>
<div class="callout-body-container callout-body">
<p>Modify the CPGâ€¦ ðŸ’»</p>
<ol type="1">
<li>Change coupling strength (<code>-0.05</code> â†’ <code>-0.03</code> or <code>-0.08</code>)</li>
<li>Try asymmetric coupling (different values for each direction)</li>
<li>Adjust external drive <code>I</code> parameter</li>
</ol>
<p>Can you create a different phase relationship?</p>
<details>
<summary>
Hint
</summary>
Stronger coupling â†’ faster synchronization<br>
Asymmetric coupling â†’ asymmetric phase relationship<br>
Higher drive â†’ faster rhythm
</details>
</div>
</div>
</section>
</section>
<section id="excitation-inhibition-balance" class="level2">
<h2 class="anchored" data-anchor-id="excitation-inhibition-balance">Excitation-Inhibition Balance</h2>
<p>Real neural networks contain both excitatory and inhibitory neurons. The balance between them is critical for stable dynamics.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>E-I Balance Principles
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><strong>Too much excitation</strong>: Runaway activity, seizures</li>
<li><strong>Too much inhibition</strong>: Network shuts down, no response<br>
</li>
<li><strong>Balanced</strong>: Stable, responsive, rich dynamics</li>
</ul>
<p>Typical cortical networks: ~80% excitatory, ~20% inhibitory neurons</p>
<p>Current Neun implementation focuses on electrical and diffusion coupling. For explicit excitatory/inhibitory synapses, you can: 1. Use coupling conductance sign and magnitude 2. Implement through the external input mechanism 3. Wait for future Neun updates with chemical synapse models!</p>
</div>
</div>
</section>
<section id="best-practices-for-network-simulations" class="level2">
<h2 class="anchored" data-anchor-id="best-practices-for-network-simulations">Best Practices for Network Simulations</h2>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Simulation Tips
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>1. Update Order Matters</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Correct order:</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> synapse <span class="kw">in</span> synapses:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    synapse.step(step)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> neuron <span class="kw">in</span> neurons:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    neuron.step(step)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>2. Pre-allocate Storage</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Efficient for large networks</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> <span class="bu">int</span>(duration <span class="op">/</span> step)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>voltages <span class="op">=</span> np.zeros((n_neurons, n_steps))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>3. Choose Appropriate Time Steps</strong> - Too large: Numerical instability - Too small: Slow simulation - Typical: 0.001-0.01 ms for HH neurons</p>
<p><strong>4. Monitor for Pathological States</strong> - Check for NaN or infinite values - Watch for runaway excitation - Validate with known behaviors</p>
</div>
</div>
</section>
<section id="advanced-topics" class="level2">
<h2 class="anchored" data-anchor-id="advanced-topics">Advanced Topics</h2>
<details>
<summary>
Scaling to Larger Networks
</summary>
<p>For networks with hundreds or thousands of neurons:</p>
<ol type="1">
<li><strong>Sparse connectivity</strong>: Not all-to-all, but random with probability <span class="math inline">\(p\)</span></li>
<li><strong>Vectorization</strong>: Use NumPy arrays for batch operations</li>
<li><strong>Precision trade-offs</strong>: Consider <code>Float</code> vs <code>Double</code></li>
<li><strong>Parallel simulation</strong>: Multiple independent networks</li>
</ol>
<p>Example sparse connection:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>connection_prob <span class="op">=</span> <span class="fl">0.1</span>  <span class="co"># 10% connectivity</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_neurons):</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n_neurons):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.random.random() <span class="op">&lt;</span> connection_prob:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create synapse between i and j</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">pass</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<details>
<summary>
Network Topology Matters
</summary>
<p>Different connectivity patterns produce different dynamics:</p>
<ul>
<li><strong>All-to-all</strong>: Strong synchronization</li>
<li><strong>Chain</strong>: Wave propagation</li>
<li><strong>Ring</strong>: Persistent traveling waves</li>
<li><strong>Random</strong>: Complex, irregular dynamics</li>
<li><strong>Small-world</strong>: Balance of local and global connectivity</li>
</ul>
Try implementing different topologies and observe the emergent dynamics!
</details>
<details>
<summary>
Analyzing Network Oscillations
</summary>
<p>Networks can generate rhythms at different frequencies:</p>
<ul>
<li><strong>Gamma (30-80 Hz)</strong>: Fast inhibitory feedback</li>
<li><strong>Beta (13-30 Hz)</strong>: Motor planning and attention</li>
<li><strong>Alpha (8-13 Hz)</strong>: Relaxed wakefulness<br>
</li>
<li><strong>Theta (4-8 Hz)</strong>: Memory and navigation</li>
</ul>
<p>Use Fourier analysis to identify oscillation frequencies:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> signal</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute power spectrum</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>freqs, psd <span class="op">=</span> signal.welch(population_rate, fs<span class="op">=</span><span class="dv">1</span><span class="op">/</span>(step<span class="op">/</span><span class="dv">1000</span>))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Find peak frequency</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>peak_freq <span class="op">=</span> freqs[np.argmax(psd)]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Peak oscillation: </span><span class="sc">{</span>peak_freq<span class="sc">:.1f}</span><span class="ss"> Hz"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>In this section, we covered:</p>
<ul>
<li>âœ… <strong>Synapse types</strong>: Electrical (gap junctions) vs diffusion (chemical-like)</li>
<li>âœ… <strong>Building networks</strong>: From simple chains to all-to-all connectivity</li>
<li>âœ… <strong>Visualization</strong>: Raster plots and population firing rates</li>
<li>âœ… <strong>Synchronization</strong>: How coupling strength affects coordination</li>
<li>âœ… <strong>Central Pattern Generators</strong>: Intrinsic rhythms from reciprocal coupling</li>
<li>âœ… <strong>Network analysis</strong>: IBIs, phase relationships, and temporal patterns</li>
</ul>
<p><strong>Key takeaways</strong>: - Synapses create the connectivity that enables network computation - Small changes in coupling can dramatically alter network behavior - Appropriate visualization reveals patterns invisible in raw data - CPGs demonstrate how networks generate complex behaviors autonomously</p>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<p>Test your understanding with these challenges:</p>
<ol type="1">
<li><p><strong>Bidirectional vs Unidirectional</strong>: Create a synapse with asymmetric coupling (different conductances in each direction). How does this affect synchronization?</p></li>
<li><p><strong>Network motifs</strong>: Build a 3-neuron network with a â€œfeedback loopâ€ (1â†’2â†’3â†’1). Compare its dynamics to a simple chain.</p></li>
<li><p><strong>Heterogeneous network</strong>: Create a network mixing HH and HR neurons. Use <code>ESynHHHRDoubleRK4</code> for cross-type connections.</p></li>
<li><p><strong>Phase analysis</strong>: For the CPG, compute the phase difference as a percentage of the cycle period. Is it stable at 50%?</p></li>
<li><p><strong>Critical coupling</strong>: Find the minimum coupling strength needed for a chain of 5 neurons to propagate a signal from first to last.</p></li>
<li><p><strong>Oscillation frequency</strong>: Modify CPG parameters to generate faster rhythms. Can you reach 10 Hz? 50 Hz?</p></li>
</ol>
<details>
<summary>
Solution Hints
</summary>
<p><strong>Ex 1</strong>: Use different values for the two conductance parameters:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>synapse <span class="op">=</span> neun_py.ESynHHHHDoubleRK4(h1, v, h2, v, <span class="op">-</span><span class="fl">0.003</span>, <span class="op">-</span><span class="fl">0.001</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Ex 3</strong>: Mix neuron types by creating different neurons and using cross-type synapse classes:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>hh_neuron <span class="op">=</span> neun_py.HHDoubleRK4(hh_args)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>hr_neuron <span class="op">=</span> neun_py.HRDoubleRK4(hr_args)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>synapse <span class="op">=</span> neun_py.ESynHHHRDoubleRK4(hh_neuron, hh_v, hr_neuron, hr_v, <span class="op">-</span>g, <span class="op">-</span>g)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<strong>Ex 6</strong>: Increase external drive <code>I</code> parameter in HR neurons for faster bursting.
</details>
<hr>
<p>ðŸ‘‰ <strong>Continue to <a href="./03-conclusions.html">Part 3: Conclusions</a></strong></p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/angellareo\.github\.io\/workshop-neun\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "2.3: Synapses and Neural Networks"</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "From Single Neurons to Connected Populations"</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-depth: 3</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: show</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>Individual neurons are the building blocks, but the real computational power of the nervous system emerges from networks. In this section, we'll explore how to connect neurons through synapses and simulate network dynamics using Neun.</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>Understanding networks requires grasping three key concepts:</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Synapses**: The connections between neurons that enable communication</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Connectivity**: The pattern of which neurons connect to which (the connectome)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Network dynamics**: The collective behavior that emerges from neuronal interactions</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="fu">## Types of Synapses</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>Neun provides two main types of synaptic connections, each with distinct properties and biological relevance:</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>::: {.panel-tabset}</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a><span class="fu">### Electrical Synapses</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>Electrical synapses (gap junctions) provide **direct electrical coupling** between neurons through protein channels that connect their cytoplasm. </span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>The current through a gap junction is proportional to the voltage difference:</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>$$I_{syn} = g_{gap} \cdot (V_1 - V_2)$$</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>where $g_{gap}$ is the gap junction conductance (typically 0.001-0.01).</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>This creates:</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Instantaneous transmission**: No synaptic delay</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Bidirectional communication**: Current flows both ways</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Synchronization**: Tendency to align neuron activity</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>**Structure**: <span class="in">`ESynN1N2PrecisionIntegrator`</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a><span class="in">```{.python filename="src/electrical-synapse.py"}</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>{{<span class="op">&lt;</span> include src<span class="op">/</span>electrical<span class="op">-</span>synapse.py <span class="op">&gt;</span>}}</span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Hands-on</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>Try modifying the coupling conductance... Are you able to change the synchronization level? ðŸ’»</span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">summary</span><span class="dt">&gt;</span>Solution<span class="dt">&lt;/</span><span class="kw">summary</span><span class="dt">&gt;</span></span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Change <span class="in">`0.002`</span> to <span class="in">`0.001`</span> (weaker coupling)</span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Change to <span class="in">`0.003`</span> (stronger coupling)</span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a>You can tell the strength of the coupling from the distance between peaks.</span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true" tabindex="-1"></a><span class="fu">### Diffusion Synapses</span></span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true" tabindex="-1"></a>Diffusion synapses model **chemical-like coupling** with time-dependent dynamics that approximate neurotransmitter diffusion across the synaptic cleft:</span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Slower transmission**: Time-dependent dynamics</span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Filtering effects**: Can smooth rapid fluctuations  </span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Biological realism**: Better models chemical synapses</span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-73"><a href="#cb15-73" aria-hidden="true" tabindex="-1"></a>**Structure**: <span class="in">`DSynN1N2PrecisionIntegrator`</span></span>
<span id="cb15-74"><a href="#cb15-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-75"><a href="#cb15-75" aria-hidden="true" tabindex="-1"></a><span class="in">```{.python filename="src/diffusion-synapse.py"}</span></span>
<span id="cb15-76"><a href="#cb15-76" aria-hidden="true" tabindex="-1"></a>{{<span class="op">&lt;</span> include src<span class="op">/</span>diffusion<span class="op">-</span>synapse.py <span class="op">&gt;</span>}}</span>
<span id="cb15-77"><a href="#cb15-77" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-78"><a href="#cb15-78" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- </span></span>
<span id="cb15-79"><a href="#cb15-79" aria-hidden="true" tabindex="-1"></a><span class="co">::: {.callout-note}</span></span>
<span id="cb15-80"><a href="#cb15-80" aria-hidden="true" tabindex="-1"></a><span class="co">## Diffusion vs Electrical</span></span>
<span id="cb15-81"><a href="#cb15-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-82"><a href="#cb15-82" aria-hidden="true" tabindex="-1"></a><span class="co">While diffusion synapses include dynamics, they're still simplified compared to full chemical synapses. For more realistic chemical transmission (with neurotransmitter release, receptors, etc.), you'd need additional mechanisms.</span></span>
<span id="cb15-83"><a href="#cb15-83" aria-hidden="true" tabindex="-1"></a><span class="co">::: --&gt;</span></span>
<span id="cb15-84"><a href="#cb15-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-85"><a href="#cb15-85" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb15-86"><a href="#cb15-86" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Hands-on</span></span>
<span id="cb15-87"><a href="#cb15-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-88"><a href="#cb15-88" aria-hidden="true" tabindex="-1"></a>Compare the two synapse types... ðŸ’»</span>
<span id="cb15-89"><a href="#cb15-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-90"><a href="#cb15-90" aria-hidden="true" tabindex="-1"></a>Run both examples and observe:</span>
<span id="cb15-91"><a href="#cb15-91" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Which shows faster coupling?</span>
<span id="cb15-92"><a href="#cb15-92" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Which produces tighter synchronization?</span>
<span id="cb15-93"><a href="#cb15-93" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How do the voltage traces differ?</span>
<span id="cb15-94"><a href="#cb15-94" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-95"><a href="#cb15-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-96"><a href="#cb15-96" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-97"><a href="#cb15-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-98"><a href="#cb15-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-99"><a href="#cb15-99" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb15-100"><a href="#cb15-100" aria-hidden="true" tabindex="-1"></a><span class="fu">## Synapse Naming Convention</span></span>
<span id="cb15-101"><a href="#cb15-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-102"><a href="#cb15-102" aria-hidden="true" tabindex="-1"></a>Neun follows a systematic naming pattern for synapses:</span>
<span id="cb15-103"><a href="#cb15-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-104"><a href="#cb15-104" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-105"><a href="#cb15-105" aria-hidden="true" tabindex="-1"></a><span class="in">{SynapseType}{Neuron1Type}{Neuron2Type}{Precision}{Integrator}</span></span>
<span id="cb15-106"><a href="#cb15-106" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-107"><a href="#cb15-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-108"><a href="#cb15-108" aria-hidden="true" tabindex="-1"></a>**Examples**:</span>
<span id="cb15-109"><a href="#cb15-109" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`ESynHHHHDoubleRK4`</span> - Electrical synapse between two HH neurons</span>
<span id="cb15-110"><a href="#cb15-110" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`DSynHRHRDoubleRK6`</span> - Diffusion synapse between two HR neurons  </span>
<span id="cb15-111"><a href="#cb15-111" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`ESynHHHRFloatRK4`</span> - Electrical synapse from HH to HR neuron</span>
<span id="cb15-112"><a href="#cb15-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-113"><a href="#cb15-113" aria-hidden="true" tabindex="-1"></a>**Important**: [Always step synapses **before** stepping neurons](step-order.qmd) in your simulation loop!</span>
<span id="cb15-114"><a href="#cb15-114" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-115"><a href="#cb15-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-116"><a href="#cb15-116" aria-hidden="true" tabindex="-1"></a><span class="fu">## Building Neural Networks</span></span>
<span id="cb15-117"><a href="#cb15-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-118"><a href="#cb15-118" aria-hidden="true" tabindex="-1"></a><span class="fu">### Chain Network</span></span>
<span id="cb15-119"><a href="#cb15-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-120"><a href="#cb15-120" aria-hidden="true" tabindex="-1"></a>Let's build a simple feedforward chain where activity propagates from one neuron to the next:</span>
<span id="cb15-121"><a href="#cb15-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-122"><a href="#cb15-122" aria-hidden="true" tabindex="-1"></a><span class="in">```{.python filename="src/neuron-chain.py"}</span></span>
<span id="cb15-123"><a href="#cb15-123" aria-hidden="true" tabindex="-1"></a>{{<span class="op">&lt;</span> include src<span class="op">/</span>neuron<span class="op">-</span>chain.py <span class="op">&gt;</span>}}</span>
<span id="cb15-124"><a href="#cb15-124" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-125"><a href="#cb15-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-126"><a href="#cb15-126" aria-hidden="true" tabindex="-1"></a>**Observation**: Notice how the spike travels through the chain with some delay. The coupling strength determines how effectively the signal propagates.</span>
<span id="cb15-127"><a href="#cb15-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-128"><a href="#cb15-128" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb15-129"><a href="#cb15-129" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Hands-on</span></span>
<span id="cb15-130"><a href="#cb15-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-131"><a href="#cb15-131" aria-hidden="true" tabindex="-1"></a>Experiment with the chain... ðŸ’»</span>
<span id="cb15-132"><a href="#cb15-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-133"><a href="#cb15-133" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Change the coupling strength (currently <span class="in">`-0.002`</span>)</span>
<span id="cb15-134"><a href="#cb15-134" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Add input to the last neuron instead of the first</span>
<span id="cb15-135"><a href="#cb15-135" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Add more neurons to the chain (change <span class="in">`4`</span> to <span class="in">`6`</span> or <span class="in">`8`</span>)</span>
<span id="cb15-136"><a href="#cb15-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-137"><a href="#cb15-137" aria-hidden="true" tabindex="-1"></a>What's the maximum chain length before signal dies out?</span>
<span id="cb15-138"><a href="#cb15-138" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-139"><a href="#cb15-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-140"><a href="#cb15-140" aria-hidden="true" tabindex="-1"></a><span class="fu">### All-to-All Network</span></span>
<span id="cb15-141"><a href="#cb15-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-142"><a href="#cb15-142" aria-hidden="true" tabindex="-1"></a>In many brain regions, neurons are densely interconnected. Let's simulate this:</span>
<span id="cb15-143"><a href="#cb15-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-144"><a href="#cb15-144" aria-hidden="true" tabindex="-1"></a><span class="in">```{.python filename="src/population-rate.py"}</span></span>
<span id="cb15-145"><a href="#cb15-145" aria-hidden="true" tabindex="-1"></a>{{<span class="op">&lt;</span> include src<span class="op">/</span>population<span class="op">-</span>rate.py <span class="op">&gt;</span>}}</span>
<span id="cb15-146"><a href="#cb15-146" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-147"><a href="#cb15-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-148"><a href="#cb15-148" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb15-149"><a href="#cb15-149" aria-hidden="true" tabindex="-1"></a><span class="fu">## All-to-All Connectivity</span></span>
<span id="cb15-150"><a href="#cb15-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-151"><a href="#cb15-151" aria-hidden="true" tabindex="-1"></a>With $N$ neurons, an all-to-all network has:</span>
<span id="cb15-152"><a href="#cb15-152" aria-hidden="true" tabindex="-1"></a>$$\text{Number of synapses} = \frac{N(N-1)}{2}$$</span>
<span id="cb15-153"><a href="#cb15-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-154"><a href="#cb15-154" aria-hidden="true" tabindex="-1"></a>This scales as $O(N^2)$, so computation grows quickly with network size!</span>
<span id="cb15-155"><a href="#cb15-155" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-156"><a href="#cb15-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-157"><a href="#cb15-157" aria-hidden="true" tabindex="-1"></a><span class="fu">## Visualizing Network Activity</span></span>
<span id="cb15-158"><a href="#cb15-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-159"><a href="#cb15-159" aria-hidden="true" tabindex="-1"></a>Understanding network behavior requires appropriate visualization tools:</span>
<span id="cb15-160"><a href="#cb15-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-161"><a href="#cb15-161" aria-hidden="true" tabindex="-1"></a><span class="fu">### Raster Plots</span></span>
<span id="cb15-162"><a href="#cb15-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-163"><a href="#cb15-163" aria-hidden="true" tabindex="-1"></a>Raster plots show **spike times** for all neurons, revealing temporal patterns:</span>
<span id="cb15-164"><a href="#cb15-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-165"><a href="#cb15-165" aria-hidden="true" tabindex="-1"></a><span class="in">```{.python filename="src/raster-plot.py"}</span></span>
<span id="cb15-166"><a href="#cb15-166" aria-hidden="true" tabindex="-1"></a>{{<span class="op">&lt;</span> include src<span class="op">/</span>raster<span class="op">-</span>plot.py <span class="op">&gt;</span>}}</span>
<span id="cb15-167"><a href="#cb15-167" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-168"><a href="#cb15-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-169"><a href="#cb15-169" aria-hidden="true" tabindex="-1"></a>**What to look for**:</span>
<span id="cb15-170"><a href="#cb15-170" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Synchrony**: Vertical alignment of spikes</span>
<span id="cb15-171"><a href="#cb15-171" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Propagation**: Diagonal patterns</span>
<span id="cb15-172"><a href="#cb15-172" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Rhythms**: Regular spacing</span>
<span id="cb15-173"><a href="#cb15-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-174"><a href="#cb15-174" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb15-175"><a href="#cb15-175" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Hands-on</span></span>
<span id="cb15-176"><a href="#cb15-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-177"><a href="#cb15-177" aria-hidden="true" tabindex="-1"></a>Analyze the raster plot... ðŸ’»</span>
<span id="cb15-178"><a href="#cb15-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-179"><a href="#cb15-179" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Can you identify synchronized events?</span>
<span id="cb15-180"><a href="#cb15-180" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Do you see traveling waves?</span>
<span id="cb15-181"><a href="#cb15-181" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Try increasing the coupling strength - what changes?</span>
<span id="cb15-182"><a href="#cb15-182" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-183"><a href="#cb15-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-184"><a href="#cb15-184" aria-hidden="true" tabindex="-1"></a><span class="fu">### Population Firing Rate</span></span>
<span id="cb15-185"><a href="#cb15-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-186"><a href="#cb15-186" aria-hidden="true" tabindex="-1"></a>The population firing rate captures **collective activity**:</span>
<span id="cb15-187"><a href="#cb15-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-188"><a href="#cb15-188" aria-hidden="true" tabindex="-1"></a>Already shown in the all-to-all network example above! The population firing rate is computed using a sliding window to count spikes across the network.</span>
<span id="cb15-189"><a href="#cb15-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-190"><a href="#cb15-190" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb15-191"><a href="#cb15-191" aria-hidden="true" tabindex="-1"></a><span class="fu">## Computing Firing Rates</span></span>
<span id="cb15-192"><a href="#cb15-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-193"><a href="#cb15-193" aria-hidden="true" tabindex="-1"></a>Common approaches:</span>
<span id="cb15-194"><a href="#cb15-194" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Spike counting**: Count spikes in time window, divide by window size</span>
<span id="cb15-195"><a href="#cb15-195" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Instantaneous rate**: Inverse of inter-spike interval</span>
<span id="cb15-196"><a href="#cb15-196" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Kernel smoothing**: Convolve spike train with Gaussian</span>
<span id="cb15-197"><a href="#cb15-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-198"><a href="#cb15-198" aria-hidden="true" tabindex="-1"></a>Each has trade-offs between temporal resolution and noise!</span>
<span id="cb15-199"><a href="#cb15-199" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-200"><a href="#cb15-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-201"><a href="#cb15-201" aria-hidden="true" tabindex="-1"></a><span class="fu">## Network Synchronization</span></span>
<span id="cb15-202"><a href="#cb15-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-203"><a href="#cb15-203" aria-hidden="true" tabindex="-1"></a>How coupled neurons synchronize depends on the **coupling strength**:</span>
<span id="cb15-204"><a href="#cb15-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-205"><a href="#cb15-205" aria-hidden="true" tabindex="-1"></a><span class="in">```{.python filename="src/coupling-strength.py"}</span></span>
<span id="cb15-206"><a href="#cb15-206" aria-hidden="true" tabindex="-1"></a>{{<span class="op">&lt;</span> include src<span class="op">/</span>coupling<span class="op">-</span>strength.py <span class="op">&gt;</span>}}</span>
<span id="cb15-207"><a href="#cb15-207" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-208"><a href="#cb15-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-209"><a href="#cb15-209" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb15-210"><a href="#cb15-210" aria-hidden="true" tabindex="-1"></a><span class="fu">## Synchronization Mechanisms</span></span>
<span id="cb15-211"><a href="#cb15-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-212"><a href="#cb15-212" aria-hidden="true" tabindex="-1"></a>Electrical synapses promote synchronization through:</span>
<span id="cb15-213"><a href="#cb15-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-214"><a href="#cb15-214" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Direct coupling**: Voltage differences drive equalizing currents</span>
<span id="cb15-215"><a href="#cb15-215" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Phase locking**: Neurons adjust their firing times to match</span>
<span id="cb15-216"><a href="#cb15-216" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Resonance**: Coupling most effective near natural frequencies</span>
<span id="cb15-217"><a href="#cb15-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-218"><a href="#cb15-218" aria-hidden="true" tabindex="-1"></a>But too much synchronization can be pathological (e.g., epilepsy)!</span>
<span id="cb15-219"><a href="#cb15-219" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-220"><a href="#cb15-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-221"><a href="#cb15-221" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb15-222"><a href="#cb15-222" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Hands-on</span></span>
<span id="cb15-223"><a href="#cb15-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-224"><a href="#cb15-224" aria-hidden="true" tabindex="-1"></a>Explore synchronization... ðŸ’»</span>
<span id="cb15-225"><a href="#cb15-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-226"><a href="#cb15-226" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>What coupling strength gives 50% synchronization?</span>
<span id="cb15-227"><a href="#cb15-227" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Is there a threshold effect?</span>
<span id="cb15-228"><a href="#cb15-228" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Try different initial voltage differences - does it matter?</span>
<span id="cb15-229"><a href="#cb15-229" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-230"><a href="#cb15-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-231"><a href="#cb15-231" aria-hidden="true" tabindex="-1"></a><span class="fu">## Central Pattern Generators (CPGs)</span></span>
<span id="cb15-232"><a href="#cb15-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-233"><a href="#cb15-233" aria-hidden="true" tabindex="-1"></a>CPGs are neural circuits that produce **rhythmic patterns** without rhythmic input. They're essential for locomotion, breathing, and other rhythmic behaviors.</span>
<span id="cb15-234"><a href="#cb15-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-235"><a href="#cb15-235" aria-hidden="true" tabindex="-1"></a>Key features of CPGs:</span>
<span id="cb15-236"><a href="#cb15-236" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Intrinsic rhythmicity**: Generated by network dynamics, not input</span>
<span id="cb15-237"><a href="#cb15-237" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Phase relationships**: Neurons fire in specific temporal order</span>
<span id="cb15-238"><a href="#cb15-238" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Robustness**: Maintain rhythm despite perturbations</span>
<span id="cb15-239"><a href="#cb15-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-240"><a href="#cb15-240" aria-hidden="true" tabindex="-1"></a><span class="fu">### Reciprocal Inhibition Model</span></span>
<span id="cb15-241"><a href="#cb15-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-242"><a href="#cb15-242" aria-hidden="true" tabindex="-1"></a>A classic CPG uses two neurons with mutual inhibition creating alternating bursts:</span>
<span id="cb15-243"><a href="#cb15-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-244"><a href="#cb15-244" aria-hidden="true" tabindex="-1"></a><span class="in">```{.python filename="src/cpg-analysis.py"}</span></span>
<span id="cb15-245"><a href="#cb15-245" aria-hidden="true" tabindex="-1"></a>{{<span class="op">&lt;</span> include src<span class="op">/</span>cpg<span class="op">-</span>analysis.py <span class="op">&gt;</span>}}</span>
<span id="cb15-246"><a href="#cb15-246" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-247"><a href="#cb15-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-248"><a href="#cb15-248" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb15-249"><a href="#cb15-249" aria-hidden="true" tabindex="-1"></a><span class="fu">## CPG Analysis Metrics</span></span>
<span id="cb15-250"><a href="#cb15-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-251"><a href="#cb15-251" aria-hidden="true" tabindex="-1"></a>**Inter-Burst Interval (IBI)**: Time between successive bursts in one neuron</span>
<span id="cb15-252"><a href="#cb15-252" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Measures rhythm regularity</span>
<span id="cb15-253"><a href="#cb15-253" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>CV of IBI &lt; 0.1 indicates regular rhythm</span>
<span id="cb15-254"><a href="#cb15-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-255"><a href="#cb15-255" aria-hidden="true" tabindex="-1"></a>**Phase Lag**: Time difference between corresponding events in two neurons</span>
<span id="cb15-256"><a href="#cb15-256" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Characterizes coordination</span>
<span id="cb15-257"><a href="#cb15-257" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>For anti-phase: lag â‰ˆ half the cycle period</span>
<span id="cb15-258"><a href="#cb15-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-259"><a href="#cb15-259" aria-hidden="true" tabindex="-1"></a>**Duty Cycle**: Fraction of time neuron is active</span>
<span id="cb15-260"><a href="#cb15-260" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Active time / cycle period</span>
<span id="cb15-261"><a href="#cb15-261" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Typical values: 0.3-0.5 for alternating rhythms</span>
<span id="cb15-262"><a href="#cb15-262" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-263"><a href="#cb15-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-264"><a href="#cb15-264" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb15-265"><a href="#cb15-265" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Hands-on</span></span>
<span id="cb15-266"><a href="#cb15-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-267"><a href="#cb15-267" aria-hidden="true" tabindex="-1"></a>Modify the CPG... ðŸ’»</span>
<span id="cb15-268"><a href="#cb15-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-269"><a href="#cb15-269" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Change coupling strength (<span class="in">`-0.05`</span> â†’ <span class="in">`-0.03`</span> or <span class="in">`-0.08`</span>)</span>
<span id="cb15-270"><a href="#cb15-270" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Try asymmetric coupling (different values for each direction)</span>
<span id="cb15-271"><a href="#cb15-271" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Adjust external drive <span class="in">`I`</span> parameter</span>
<span id="cb15-272"><a href="#cb15-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-273"><a href="#cb15-273" aria-hidden="true" tabindex="-1"></a>Can you create a different phase relationship?</span>
<span id="cb15-274"><a href="#cb15-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-275"><a href="#cb15-275" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-276"><a href="#cb15-276" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">summary</span><span class="dt">&gt;</span>Hint<span class="dt">&lt;/</span><span class="kw">summary</span><span class="dt">&gt;</span></span>
<span id="cb15-277"><a href="#cb15-277" aria-hidden="true" tabindex="-1"></a>Stronger coupling â†’ faster synchronization  </span>
<span id="cb15-278"><a href="#cb15-278" aria-hidden="true" tabindex="-1"></a>Asymmetric coupling â†’ asymmetric phase relationship  </span>
<span id="cb15-279"><a href="#cb15-279" aria-hidden="true" tabindex="-1"></a>Higher drive â†’ faster rhythm</span>
<span id="cb15-280"><a href="#cb15-280" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-281"><a href="#cb15-281" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-282"><a href="#cb15-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-283"><a href="#cb15-283" aria-hidden="true" tabindex="-1"></a><span class="fu">## Excitation-Inhibition Balance</span></span>
<span id="cb15-284"><a href="#cb15-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-285"><a href="#cb15-285" aria-hidden="true" tabindex="-1"></a>Real neural networks contain both excitatory and inhibitory neurons. The balance between them is critical for stable dynamics.</span>
<span id="cb15-286"><a href="#cb15-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-287"><a href="#cb15-287" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb15-288"><a href="#cb15-288" aria-hidden="true" tabindex="-1"></a><span class="fu">## E-I Balance Principles</span></span>
<span id="cb15-289"><a href="#cb15-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-290"><a href="#cb15-290" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Too much excitation**: Runaway activity, seizures</span>
<span id="cb15-291"><a href="#cb15-291" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Too much inhibition**: Network shuts down, no response  </span>
<span id="cb15-292"><a href="#cb15-292" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Balanced**: Stable, responsive, rich dynamics</span>
<span id="cb15-293"><a href="#cb15-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-294"><a href="#cb15-294" aria-hidden="true" tabindex="-1"></a>Typical cortical networks: ~80% excitatory, ~20% inhibitory neurons</span>
<span id="cb15-295"><a href="#cb15-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-296"><a href="#cb15-296" aria-hidden="true" tabindex="-1"></a>Current Neun implementation focuses on electrical and diffusion coupling. For explicit excitatory/inhibitory synapses, you can:</span>
<span id="cb15-297"><a href="#cb15-297" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Use coupling conductance sign and magnitude</span>
<span id="cb15-298"><a href="#cb15-298" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Implement through the external input mechanism</span>
<span id="cb15-299"><a href="#cb15-299" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Wait for future Neun updates with chemical synapse models!</span>
<span id="cb15-300"><a href="#cb15-300" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-301"><a href="#cb15-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-302"><a href="#cb15-302" aria-hidden="true" tabindex="-1"></a><span class="fu">## Best Practices for Network Simulations</span></span>
<span id="cb15-303"><a href="#cb15-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-304"><a href="#cb15-304" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb15-305"><a href="#cb15-305" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation Tips</span></span>
<span id="cb15-306"><a href="#cb15-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-307"><a href="#cb15-307" aria-hidden="true" tabindex="-1"></a>**1. Update Order Matters**</span>
<span id="cb15-308"><a href="#cb15-308" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb15-309"><a href="#cb15-309" aria-hidden="true" tabindex="-1"></a><span class="co"># Correct order:</span></span>
<span id="cb15-310"><a href="#cb15-310" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> synapse <span class="kw">in</span> synapses:</span>
<span id="cb15-311"><a href="#cb15-311" aria-hidden="true" tabindex="-1"></a>    synapse.step(step)</span>
<span id="cb15-312"><a href="#cb15-312" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-313"><a href="#cb15-313" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> neuron <span class="kw">in</span> neurons:</span>
<span id="cb15-314"><a href="#cb15-314" aria-hidden="true" tabindex="-1"></a>    neuron.step(step)</span>
<span id="cb15-315"><a href="#cb15-315" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-316"><a href="#cb15-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-317"><a href="#cb15-317" aria-hidden="true" tabindex="-1"></a>**2. Pre-allocate Storage**</span>
<span id="cb15-318"><a href="#cb15-318" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb15-319"><a href="#cb15-319" aria-hidden="true" tabindex="-1"></a><span class="co"># Efficient for large networks</span></span>
<span id="cb15-320"><a href="#cb15-320" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> <span class="bu">int</span>(duration <span class="op">/</span> step)</span>
<span id="cb15-321"><a href="#cb15-321" aria-hidden="true" tabindex="-1"></a>voltages <span class="op">=</span> np.zeros((n_neurons, n_steps))</span>
<span id="cb15-322"><a href="#cb15-322" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-323"><a href="#cb15-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-324"><a href="#cb15-324" aria-hidden="true" tabindex="-1"></a>**3. Choose Appropriate Time Steps**</span>
<span id="cb15-325"><a href="#cb15-325" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Too large: Numerical instability</span>
<span id="cb15-326"><a href="#cb15-326" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Too small: Slow simulation</span>
<span id="cb15-327"><a href="#cb15-327" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Typical: 0.001-0.01 ms for HH neurons</span>
<span id="cb15-328"><a href="#cb15-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-329"><a href="#cb15-329" aria-hidden="true" tabindex="-1"></a>**4. Monitor for Pathological States**</span>
<span id="cb15-330"><a href="#cb15-330" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Check for NaN or infinite values</span>
<span id="cb15-331"><a href="#cb15-331" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Watch for runaway excitation</span>
<span id="cb15-332"><a href="#cb15-332" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Validate with known behaviors</span>
<span id="cb15-333"><a href="#cb15-333" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb15-334"><a href="#cb15-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-335"><a href="#cb15-335" aria-hidden="true" tabindex="-1"></a><span class="fu">## Advanced Topics</span></span>
<span id="cb15-336"><a href="#cb15-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-337"><a href="#cb15-337" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-338"><a href="#cb15-338" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">summary</span><span class="dt">&gt;</span>Scaling to Larger Networks<span class="dt">&lt;/</span><span class="kw">summary</span><span class="dt">&gt;</span></span>
<span id="cb15-339"><a href="#cb15-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-340"><a href="#cb15-340" aria-hidden="true" tabindex="-1"></a>For networks with hundreds or thousands of neurons:</span>
<span id="cb15-341"><a href="#cb15-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-342"><a href="#cb15-342" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Sparse connectivity**: Not all-to-all, but random with probability $p$</span>
<span id="cb15-343"><a href="#cb15-343" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Vectorization**: Use NumPy arrays for batch operations</span>
<span id="cb15-344"><a href="#cb15-344" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Precision trade-offs**: Consider <span class="in">`Float`</span> vs <span class="in">`Double`</span></span>
<span id="cb15-345"><a href="#cb15-345" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Parallel simulation**: Multiple independent networks</span>
<span id="cb15-346"><a href="#cb15-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-347"><a href="#cb15-347" aria-hidden="true" tabindex="-1"></a>Example sparse connection:</span>
<span id="cb15-348"><a href="#cb15-348" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb15-349"><a href="#cb15-349" aria-hidden="true" tabindex="-1"></a>connection_prob <span class="op">=</span> <span class="fl">0.1</span>  <span class="co"># 10% connectivity</span></span>
<span id="cb15-350"><a href="#cb15-350" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_neurons):</span>
<span id="cb15-351"><a href="#cb15-351" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n_neurons):</span>
<span id="cb15-352"><a href="#cb15-352" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.random.random() <span class="op">&lt;</span> connection_prob:</span>
<span id="cb15-353"><a href="#cb15-353" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create synapse between i and j</span></span>
<span id="cb15-354"><a href="#cb15-354" aria-hidden="true" tabindex="-1"></a>            <span class="cf">pass</span></span>
<span id="cb15-355"><a href="#cb15-355" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-356"><a href="#cb15-356" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-357"><a href="#cb15-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-358"><a href="#cb15-358" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-359"><a href="#cb15-359" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">summary</span><span class="dt">&gt;</span>Network Topology Matters<span class="dt">&lt;/</span><span class="kw">summary</span><span class="dt">&gt;</span></span>
<span id="cb15-360"><a href="#cb15-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-361"><a href="#cb15-361" aria-hidden="true" tabindex="-1"></a>Different connectivity patterns produce different dynamics:</span>
<span id="cb15-362"><a href="#cb15-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-363"><a href="#cb15-363" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**All-to-all**: Strong synchronization</span>
<span id="cb15-364"><a href="#cb15-364" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Chain**: Wave propagation</span>
<span id="cb15-365"><a href="#cb15-365" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Ring**: Persistent traveling waves</span>
<span id="cb15-366"><a href="#cb15-366" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Random**: Complex, irregular dynamics</span>
<span id="cb15-367"><a href="#cb15-367" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Small-world**: Balance of local and global connectivity</span>
<span id="cb15-368"><a href="#cb15-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-369"><a href="#cb15-369" aria-hidden="true" tabindex="-1"></a>Try implementing different topologies and observe the emergent dynamics!</span>
<span id="cb15-370"><a href="#cb15-370" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-371"><a href="#cb15-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-372"><a href="#cb15-372" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-373"><a href="#cb15-373" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">summary</span><span class="dt">&gt;</span>Analyzing Network Oscillations<span class="dt">&lt;/</span><span class="kw">summary</span><span class="dt">&gt;</span></span>
<span id="cb15-374"><a href="#cb15-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-375"><a href="#cb15-375" aria-hidden="true" tabindex="-1"></a>Networks can generate rhythms at different frequencies:</span>
<span id="cb15-376"><a href="#cb15-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-377"><a href="#cb15-377" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Gamma (30-80 Hz)**: Fast inhibitory feedback</span>
<span id="cb15-378"><a href="#cb15-378" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Beta (13-30 Hz)**: Motor planning and attention</span>
<span id="cb15-379"><a href="#cb15-379" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Alpha (8-13 Hz)**: Relaxed wakefulness  </span>
<span id="cb15-380"><a href="#cb15-380" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Theta (4-8 Hz)**: Memory and navigation</span>
<span id="cb15-381"><a href="#cb15-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-382"><a href="#cb15-382" aria-hidden="true" tabindex="-1"></a>Use Fourier analysis to identify oscillation frequencies:</span>
<span id="cb15-383"><a href="#cb15-383" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb15-384"><a href="#cb15-384" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> signal</span>
<span id="cb15-385"><a href="#cb15-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-386"><a href="#cb15-386" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute power spectrum</span></span>
<span id="cb15-387"><a href="#cb15-387" aria-hidden="true" tabindex="-1"></a>freqs, psd <span class="op">=</span> signal.welch(population_rate, fs<span class="op">=</span><span class="dv">1</span><span class="op">/</span>(step<span class="op">/</span><span class="dv">1000</span>))</span>
<span id="cb15-388"><a href="#cb15-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-389"><a href="#cb15-389" aria-hidden="true" tabindex="-1"></a><span class="co"># Find peak frequency</span></span>
<span id="cb15-390"><a href="#cb15-390" aria-hidden="true" tabindex="-1"></a>peak_freq <span class="op">=</span> freqs[np.argmax(psd)]</span>
<span id="cb15-391"><a href="#cb15-391" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Peak oscillation: </span><span class="sc">{</span>peak_freq<span class="sc">:.1f}</span><span class="ss"> Hz"</span>)</span>
<span id="cb15-392"><a href="#cb15-392" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-393"><a href="#cb15-393" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-394"><a href="#cb15-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-395"><a href="#cb15-395" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb15-396"><a href="#cb15-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-397"><a href="#cb15-397" aria-hidden="true" tabindex="-1"></a>In this section, we covered:</span>
<span id="cb15-398"><a href="#cb15-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-399"><a href="#cb15-399" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>âœ… **Synapse types**: Electrical (gap junctions) vs diffusion (chemical-like)</span>
<span id="cb15-400"><a href="#cb15-400" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>âœ… **Building networks**: From simple chains to all-to-all connectivity</span>
<span id="cb15-401"><a href="#cb15-401" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>âœ… **Visualization**: Raster plots and population firing rates</span>
<span id="cb15-402"><a href="#cb15-402" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>âœ… **Synchronization**: How coupling strength affects coordination</span>
<span id="cb15-403"><a href="#cb15-403" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>âœ… **Central Pattern Generators**: Intrinsic rhythms from reciprocal coupling</span>
<span id="cb15-404"><a href="#cb15-404" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>âœ… **Network analysis**: IBIs, phase relationships, and temporal patterns</span>
<span id="cb15-405"><a href="#cb15-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-406"><a href="#cb15-406" aria-hidden="true" tabindex="-1"></a>**Key takeaways**:</span>
<span id="cb15-407"><a href="#cb15-407" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Synapses create the connectivity that enables network computation</span>
<span id="cb15-408"><a href="#cb15-408" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Small changes in coupling can dramatically alter network behavior</span>
<span id="cb15-409"><a href="#cb15-409" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Appropriate visualization reveals patterns invisible in raw data</span>
<span id="cb15-410"><a href="#cb15-410" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>CPGs demonstrate how networks generate complex behaviors autonomously</span>
<span id="cb15-411"><a href="#cb15-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-412"><a href="#cb15-412" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercises</span></span>
<span id="cb15-413"><a href="#cb15-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-414"><a href="#cb15-414" aria-hidden="true" tabindex="-1"></a>Test your understanding with these challenges:</span>
<span id="cb15-415"><a href="#cb15-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-416"><a href="#cb15-416" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Bidirectional vs Unidirectional**: Create a synapse with asymmetric coupling (different conductances in each direction). How does this affect synchronization?</span>
<span id="cb15-417"><a href="#cb15-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-418"><a href="#cb15-418" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Network motifs**: Build a 3-neuron network with a "feedback loop" (1â†’2â†’3â†’1). Compare its dynamics to a simple chain.</span>
<span id="cb15-419"><a href="#cb15-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-420"><a href="#cb15-420" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Heterogeneous network**: Create a network mixing HH and HR neurons. Use <span class="in">`ESynHHHRDoubleRK4`</span> for cross-type connections.</span>
<span id="cb15-421"><a href="#cb15-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-422"><a href="#cb15-422" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Phase analysis**: For the CPG, compute the phase difference as a percentage of the cycle period. Is it stable at 50%?</span>
<span id="cb15-423"><a href="#cb15-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-424"><a href="#cb15-424" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Critical coupling**: Find the minimum coupling strength needed for a chain of 5 neurons to propagate a signal from first to last.</span>
<span id="cb15-425"><a href="#cb15-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-426"><a href="#cb15-426" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**Oscillation frequency**: Modify CPG parameters to generate faster rhythms. Can you reach 10 Hz? 50 Hz?</span>
<span id="cb15-427"><a href="#cb15-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-428"><a href="#cb15-428" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-429"><a href="#cb15-429" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">summary</span><span class="dt">&gt;</span>Solution Hints<span class="dt">&lt;/</span><span class="kw">summary</span><span class="dt">&gt;</span></span>
<span id="cb15-430"><a href="#cb15-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-431"><a href="#cb15-431" aria-hidden="true" tabindex="-1"></a>**Ex 1**: Use different values for the two conductance parameters:</span>
<span id="cb15-432"><a href="#cb15-432" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb15-433"><a href="#cb15-433" aria-hidden="true" tabindex="-1"></a>synapse <span class="op">=</span> neun_py.ESynHHHHDoubleRK4(h1, v, h2, v, <span class="op">-</span><span class="fl">0.003</span>, <span class="op">-</span><span class="fl">0.001</span>)</span>
<span id="cb15-434"><a href="#cb15-434" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-435"><a href="#cb15-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-436"><a href="#cb15-436" aria-hidden="true" tabindex="-1"></a>**Ex 3**: Mix neuron types by creating different neurons and using cross-type synapse classes:</span>
<span id="cb15-437"><a href="#cb15-437" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb15-438"><a href="#cb15-438" aria-hidden="true" tabindex="-1"></a>hh_neuron <span class="op">=</span> neun_py.HHDoubleRK4(hh_args)</span>
<span id="cb15-439"><a href="#cb15-439" aria-hidden="true" tabindex="-1"></a>hr_neuron <span class="op">=</span> neun_py.HRDoubleRK4(hr_args)</span>
<span id="cb15-440"><a href="#cb15-440" aria-hidden="true" tabindex="-1"></a>synapse <span class="op">=</span> neun_py.ESynHHHRDoubleRK4(hh_neuron, hh_v, hr_neuron, hr_v, <span class="op">-</span>g, <span class="op">-</span>g)</span>
<span id="cb15-441"><a href="#cb15-441" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb15-442"><a href="#cb15-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-443"><a href="#cb15-443" aria-hidden="true" tabindex="-1"></a>**Ex 6**: Increase external drive <span class="in">`I`</span> parameter in HR neurons for faster bursting.</span>
<span id="cb15-444"><a href="#cb15-444" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">details</span><span class="dt">&gt;</span></span>
<span id="cb15-445"><a href="#cb15-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-446"><a href="#cb15-446" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb15-447"><a href="#cb15-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-448"><a href="#cb15-448" aria-hidden="true" tabindex="-1"></a>ðŸ‘‰ **Continue to [Part 3: Conclusions](03-conclusions.qmd)**</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>